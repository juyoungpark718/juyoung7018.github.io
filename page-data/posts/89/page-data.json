{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/89/","result":{"data":{"markdownRemark":{"html":"<ul>\n<li>\n<p><strong>Git</strong></p>\n<ul>\n<li>\n<p>Git을 사용하는 이유?</p>\n<ol>\n<li>\n<p>버전관리.</p>\n<p>git commit 하는 과정은 버전을 하나씩 만든다고 생각하면 됨.</p>\n</li>\n<li>\n<p>백업.</p>\n<p>로컬저장소에서 원격저장소에 올리는 행위(git push)</p>\n<p>원격저장소에서 로컬로 가져오는 행위(git pull)</p>\n</li>\n<li>\n<p>협업.</p>\n<p>백업은 나 혼자만 사용하는거라면 협업은 여러 사람이 이용하면 협업.</p>\n<p>하지만, 같은 파일을 수정하는 경우? 이런 경우를 Git이 잘 해결해줌.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>.git ⇒ repository 버전을 저장하는 곳.</p>\n</li>\n<li>\n<p>working tree 버전으로 만들어지는 전 단계.</p>\n</li>\n<li>\n<p>staging Area 버전으로 만들 파일들을 올리는 곳. → 여기서 이제 repository로 가면 버전이 생성.</p>\n</li>\n<li>\n<p>branch</p>\n<ul>\n<li>git branch 하면 목록을 볼수있음.</li>\n<li>git branch {이름} branch를 만들 수 있음.\n<ul>\n<li>git log —all —graph —oneline으로 확인 가능.</li>\n</ul>\n</li>\n<li>같은 뿌리에서 나왔지만 이후에 서로 다른 commit을 가지는 버전.</li>\n<li>같은 폴더인데 병합하려고하면 conflict(충돌이 일어남.) → 수동으로 수정.</li>\n<li>checkout 명령어를 사용해 branch를 바꿀 수 있음.</li>\n</ul>\n</li>\n<li>\n<p>git 명령어</p>\n<ul>\n<li>\n<p>init</p>\n<ul>\n<li>현재의 디렉토리를 Git 저장소로 초기화.</li>\n</ul>\n</li>\n<li>\n<p>status</p>\n<ul>\n<li>상태를 물어보는 명령어.\n<ul>\n<li>Untracked files ⇒ add로 올려줘야 git에서 관리를 함.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>add</p>\n<ul>\n<li>untracked file들을 올려줌.</li>\n<li>버전이 될 파일들의 목록.</li>\n</ul>\n</li>\n<li>\n<p>commit</p>\n<ul>\n<li>버전을 만들어 주는 것.</li>\n<li>commit 옵션들.</li>\n</ul>\n</li>\n<li>\n<p>log</p>\n<ul>\n<li>commit(버전)을 확인하고 싶을때,(q를 누르면 나가짐.)</li>\n<li>옵션들</li>\n</ul>\n</li>\n<li>\n<p>diff</p>\n<ul>\n<li>변경된 파일 내용의 원본과 바뀐 파일의 차이를 보여줌.</li>\n<li>버전을 만들기전의 차이.</li>\n</ul>\n</li>\n<li>\n<p>checkout</p>\n<ul>\n<li>이전의 commit 즉 이전 버전으로 가고 싶을때 사용.\n<ul>\n<li>git log를 하면 이전의 커밋이 없어진것처럼 보임.(HEAD가 옮겨진 것)</li>\n</ul>\n</li>\n<li>git checkout master를 하게되면 HEAD가 다시 master로 가서 최신으로 유지.</li>\n</ul>\n</li>\n<li>\n<p>reset(삭제)</p>\n<ul>\n<li>해당 버전(commit)으로 되겠다. 돌아가겠다 정도로 생각하면 됨.</li>\n<li><strong>주의! 다른 사람 버전에는 하면 안됨.(협업 시)</strong></li>\n<li>옵션들\n<ul>\n<li>—hard : 우리가 수정하고 있던 것까지 되돌림.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>revert(버전은 납두고 되돌림)</p>\n<ul>\n<li>삭제 , 보존의 목적 둘 다 달성 가능.</li>\n<li>reset과 다르게 이전 버전으로 돌아가기 위해서는 현재 버전을 revert해야함.\n<ul>\n<li>ex) R4에서 R3로 가고 싶으면 R4에서 해야함.</li>\n<li>주의해야할 것은 역순으로 revert를 해야 충돌이 안일어남.(R2를 하려면 R4,R3를 해야함)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>branch</p>\n<ul>\n<li>git branch 하면 목록을 볼수있음.</li>\n<li>git branch {이름} branch를 만들 수 있음.\n<ul>\n<li>git log —all —graph —oneline으로 확인 가능.</li>\n</ul>\n</li>\n<li>같은 뿌리에서 나왔지만 이후에 서로 다른 commit을 가지는 버전.</li>\n<li>같은 폴더인데 병합하려고하면 conflict(충돌이 일어남.) → 수동으로 수정.</li>\n<li>checkout 명령어를 사용해 branch를 바꿀 수 있음.</li>\n</ul>\n</li>\n<li>\n<p>merge</p>\n<ul>\n<li>서로 다른 branch를 합침.</li>\n<li>합치려고 하는 공통의 조상을 base라고 함 그리고 그것을 합치면 ⇒ merge commit\n<ul>\n<li>3가지를 비교해서 변경된 사항들은 conflict없이 바로 변경.</li>\n<li>cf) 2가지를 비교하게 되면 다른 부분은 모두 conflict가 일어남.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>fetch vs pull</p>\n<ul>\n<li>fetch는 코드만 가져옴.</li>\n<li>pull은 코드를 가져와서 merge. → conflict가 일어날 수 있음.</li>\n<li>rebase를 이용한 fork 원본저장소랑 최신 유지 참고 사이트\n<ul>\n<li><a href=\"https://junwoo45.github.io/2019-10-23-rebase/\">https://junwoo45.github.io/2019-10-23-rebase/</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>이번에 쓴 clone 명령어 옵션.</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">git clone 주소 -b {branch이름} —single-branch\n</code></pre>\n<p>깃 클론시 다른 브랜치들은 가져오지 않고 해당 브랜치만 가져와서 클론.(많은 브랜치들이 있을때 유용.)</p>\n</li>\n</ul>","frontmatter":{"title":"Git과 명령어","date":"2020년 07월 28일, 22:50"}}},"pageContext":{"slug":"/9/post89/","previous":{"fields":{"slug":"/9/post88/"},"frontmatter":{"title":"[백준] 9205번 맥주마시면서걸어가기(완)","path":"/posts/88"}},"next":{"fields":{"slug":"/10/post90/"},"frontmatter":{"title":"복잡도와 LinkedList","path":"/posts/90"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}