{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/64/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>수식 최대화</h2>\n<h3>문제 설명</h3>\n<p>IT 벤처 회사를 운영하고 있는 <code>라이언</code>은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.<br>\n이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.<br>\n해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(<code>+, -, *</code>) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.<br>\n단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + > - > _ 또는 - > _ > + 등과 같이 연산자 우선순위를 정의할 수 있으나 <code>+</code>,<code>*</code> > <code>-</code> 또는 <code>*</code> > <code>+</code>,<code>-</code>처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.<br>\n만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다.</p>\n<p>예를 들어, 참가자 중 <code>네오</code>가 아래와 같은 수식을 전달받았다고 가정합니다.</p>\n<p><code>\"100-200*300-500+20\"</code></p>\n<p>일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 <code>*</code> > <code>+</code>,<code>-</code> 로 우선순위가 정의되어 있습니다.<br>\n대회 규칙에 따라 <code>+</code> > <code>-</code> > <code>*</code> 또는 <code>-</code> > <code>*</code> > <code>+</code> 등과 같이 연산자 우선순위를 정의할 수 있으나 <code>+</code>,<code>*</code> > <code>-</code> 또는 <code>*</code> > <code>+</code>,<code>-</code> 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.\n수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 <code>+</code> > <code>-</code> > <code>*</code> 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.<br>\n반면에 <code>*</code> > <code>+</code> > <code>-</code> 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다.</p>\n<p>참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요.</p>\n<p><strong><em>[제한사항]</em></strong></p>\n<ul>\n<li>expression은 길이가 3 이상 100 이하인 문자열입니다.</li>\n<li>expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(<code>+</code>, <code>-</code>, <code>*</code>) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다.\n<ul>\n<li>즉, <code>\"402+-561*\"</code>처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다.</li>\n</ul>\n</li>\n<li>expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다.\n<ul>\n<li>즉, <code>\"100-2145*458+12\"</code>처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다.</li>\n<li><code>\"-56+100\"</code>처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다.</li>\n</ul>\n</li>\n<li>expression은 적어도 1개 이상의 연산자를 포함하고 있습니다.</li>\n<li>연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다.</li>\n<li>같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다.</li>\n</ul>\n<p><strong><em>입출력 예</em></strong></p>\n<table>\n<thead>\n<tr>\n<th>expression</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\"100-200*300-500+20\"</td>\n<td>60420</td>\n</tr>\n<tr>\n<td>\"50* 6-3*2\"</td>\n<td>300</td>\n</tr>\n</tbody>\n</table>\n<p><strong><em>입출력 예에 대한 설명</em></strong></p>\n<p><strong>입출력 예 #1</strong><br>\n<code>*</code> > <code>+</code> > <code>-</code> 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.<br>\n연산 순서는 아래와 같습니다.<br>\n<code>100-200*300-500+20</code><br>\n= <code>100-(200*300)-500+20</code><br>\n= <code>100-60000-(500+20)</code><br>\n= <code>(100-60000)-520</code><br>\n= <code>(-59900-520)</code><br>\n= <code>-60420</code><br>\n따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다.</p>\n<p><strong>입출력 예 #2</strong> > <code>-</code> > <code>*</code> 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.<br>\n연산 순서는 아래와 같습니다.(expression에서 <code>+</code> 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.)<br>\n<code>50*6-3*2</code><br>\n= <code>50*(6-3)*2</code><br>\n= <code>(50*3)*2</code><br>\n= <code>150*2</code><br>\n= <code>300</code><br>\n따라서, 우승 시 받을 수 있는 상금은 300 입니다.</p>\n</blockquote>\n<h3>문제풀이</h3>\n<ol>\n<li>정규식을 이용해서 연산자, 피연산자를 나눠줌.</li>\n<li>3가지의 연산자 밖에 없으므로, 전역 변수를 경우의 수만큼 그냥 선언.</li>\n<li>경우의 수만큼 for문을 돌린다.</li>\n<li>계산을 담을 rand를 선언.</li>\n<li>operators의 각 원소들에 대해서도 for문을 돌려서 계산을 해야함.</li>\n<li>새로운 newRand배열을 만들고, rand를 돌면서 연산자가 들어왔을때는,\n<ol>\n<li>newRand에서 pop한 값과 rand[i],rand[i+1]을 이용해서 값을 구하고 다시 newRand에 넣어준다.</li>\n<li>연산자가 아닌 경우는 newRand에 그냥 push한다.</li>\n<li>모든 rand를 돌고 난 후에는 rand를 newRand로 바꿔준다.</li>\n</ol>\n</li>\n<li>rand의 길이가 1이면 result에 push한다.</li>\n<li>result를 절댓값으로 정렬하고, 절댓값이 가장 큰 값으로 리턴한다.</li>\n</ol>\n<pre><code class=\"language-js\">const operators = [\n  [\"*\", \"+\", \"-\"],\n  [\"*\", \"-\", \"+\"],\n  [\"+\", \"*\", \"-\"],\n  [\"+\", \"-\", \"*\"],\n  [\"-\", \"+\", \"*\"],\n  [\"-\", \"*\", \"+\"],\n];\nfunction solution(expression) {\n  var answer = 0;\n  let result = [];\n  let operand = expression.split(/([+\\-*/])/);\n  operators.forEach(e => {\n    let rands = [...operand];\n    e.forEach(operator => {\n      let newRands = [];\n      for (let i = 0; i &#x3C; rands.length; i++) {\n        if (rands[i] === operator) {\n          let op1 = newRands.pop();\n          let op2 = rands[i + 1];\n          newRands.push(cal(op1, op2, operator));\n          i++;\n        } else newRands.push(rands[i]);\n      }\n      rands = [...newRands];\n    });\n    if (rands.length === 1) result.push(rands[0]);\n  });\n  result.sort((a, b) => Math.abs(b) - Math.abs(a));\n  return Math.abs(result[0]);\n}\n\nfunction cal(op1, op2, operator) {\n  op1 = Number(op1);\n  op2 = Number(op2);\n  switch (operator) {\n    case \"*\":\n      return op1 * op2;\n    case \"-\":\n      return op1 - op2;\n    case \"+\":\n      return op1 + op2;\n    default:\n      return -1;\n  }\n}\n</code></pre>","frontmatter":{"title":"[프로그래머스] 레벨2 (level2) 수식 최대화","date":"2020년 07월 04일, 10:45"}}},"pageContext":{"slug":"/7/post64/","previous":{"fields":{"slug":"/7/post63/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 보석 쇼핑","path":"/posts/63"}},"next":{"fields":{"slug":"/7/post65/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 경주로 건설","path":"/posts/65"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}