{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/98/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>징검다리</h2>\n<h3>문제 설명</h3>\n<p>출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다.\n예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다.</p>\n<table>\n<thead>\n<tr>\n<th>제거한 바위의 위치</th>\n<th>각 바위 사이의 거리</th>\n<th>거리의 최솟값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[21, 17]</td>\n<td>[2, 9, 3, 11]</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[2, 21]</td>\n<td>[11, 3, 3, 8]</td>\n<td>3</td>\n</tr>\n<tr>\n<td>[2, 11]</td>\n<td>[14, 3, 4, 4]</td>\n<td>3</td>\n</tr>\n<tr>\n<td>[11, 21]</td>\n<td>[2, 12, 3, 8]</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[2, 14]</td>\n<td>[11, 6, 4, 4]</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p>위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.</p>\n<p>출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.</p>\n<p><strong>제한사항</strong></p>\n<ul>\n<li>도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.</li>\n<li>바위는 1개 이상 50,000개 이하가 있습니다.</li>\n<li>n 은 1 이상 바위의 개수 이하입니다.</li>\n</ul>\n<p><strong>입출력 예</strong></p>\n<table>\n<thead>\n<tr>\n<th>distance</th>\n<th>rocks</th>\n<th>n</th>\n<th>return</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>25</td>\n<td>[2, 14, 11, 21, 17]</td>\n<td>2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h3>문제풀이</h3>\n<ol>\n<li>rocks들을 정렬해서 서로 거리를 구할 수 있게 한다.</li>\n<li>이분 탐색을 이용해서 푼다.</li>\n<li>rocks를 돌면서, mid값보다 작은 수가 있을 경우에는 바위를 제거.</li>\n<li>mid값보다 크다면, 바위의 위치를 바꿈.</li>\n<li>count에 따라서 left,right를 바꿔줌.</li>\n</ol>\n<pre><code class=\"language-js\">/*\nn만큼 제거 해야함.\n제거 시 거리의 최솟값을 구할거임.\n그 거리들의 최솟값 중 최댓값을 구함.\n\nmid가 최솟값이라고 가정.\nmid보다 작은 애가 있다면 돌을 지움.\n계속 진행. count가 n보다 크면 right를 줄이고, count가 n보다 작으면 left를 늘림.\n*/\n\nfunction solution(distance, rocks, n) {\n  var answer = 0;\n  rocks.sort((a, b) => a - b);\n  let left = 0;\n  let right = distance;\n  let maxValue = 0;\n\n  while (left &#x3C;= right) {\n    let mid = parseInt((left + right) / 2);\n    let prev = 0;\n    let min = Infinity;\n    let count = 0;\n\n    for (let i = 0; i &#x3C; rocks.length; i++) {\n      if (count > n) break;\n      let d = rocks[i] - prev;\n      if (mid > d) {\n        count++;\n      } else {\n        min = min > d ? d : min;\n        prev = rocks[i];\n      }\n      d = distance - prev;\n      min = min > d ? d : min;\n    }\n    if (count &#x3C;= n) {\n      left = mid + 1;\n      maxValue = Math.max(maxValue, min);\n    } else {\n      right = mid - 1;\n    }\n  }\n  answer = maxValue;\n  return answer;\n}\n</code></pre>","frontmatter":{"title":"[프로그래머스] 레벨4 (level4) 징검다리","date":"2020년 08월 27일, 21:40"}}},"pageContext":{"slug":"/10/post98/","previous":{"fields":{"slug":"/10/post97/"},"frontmatter":{"title":"[백준] 1920번 수 찾기","path":"/posts/97"}},"next":{"fields":{"slug":"/10/post99/"},"frontmatter":{"title":"[백준] 14888번 연산자 끼워넣기","path":"/posts/99"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}