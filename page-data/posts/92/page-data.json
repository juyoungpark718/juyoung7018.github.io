{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/92/","result":{"data":{"markdownRemark":{"html":"<h3>다익스트라 알고리즘</h3>\n<ul>\n<li>\n<p>다익스트라?</p>\n<ul>\n<li>다이나믹 프로그래밍을 이용한 최단 경로 알고리즘.\n<ul>\n<li>다른 정점까지의 최단거리를 구할 때 이전의 값을 사용.(메모지에이션.)</li>\n</ul>\n</li>\n<li>단, 음의 간선이 있는 경우 사용할 수 없음.(왜?)\n<ul>\n<li>무한 루프가 가능해서? -> 방문한 정점을 다시 안가게 하면 어떨까? 하지만 방문한 정점을 안가게 하면 그 정점이 값이 바뀌는 경우에 대처를 못함.\n<ul>\n<li>그래서 방문을 사용하는 경우에는 값이 바뀌면 방문을 false 다시 바꿔주고, 끝나는 조건을 모든 정점이 true인 경우로 해줘야 한다.</li>\n<li>그래서 음의 가중치가 있으면 계속 갱신이 되기 때문에 안된다.</li>\n<li>방문을 사용하지 않으면, 현재 distance와 과거 distance를 비교해서 현재 distance가 과거 distance보다 작다면, 다시 queue에 넣을 필요가 없다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>작동 원리</p>\n<ol>\n<li>특정 하나의 정점으로부터 시작.</li>\n<li>이웃한 정점들에서 비용이 가장 작은 노드를 선택(방문하지 않은 노드여야 함).</li>\n<li>선택한 노드에서 다른 노드 까지 가는 비용을 업데이트(거쳐서 간다는 느낌. 만약 1->2 로 가는거보다 1->3->2로 가는게 작다면 갱신됨.)</li>\n<li>2.3번 을 반복하여 모든 정점을 방문할 때 까지 반복.</li>\n</ol>\n</li>\n<li>\n<p>코드</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">const setArray = (n, fillValue) => Array(n + 1).fill(fillValue);\n\nconst setTwoDimensionArr = (n, fillValue) =>\n  Array.from(Array(n + 1), () => Array(n + 1).fill(fillValue));\n\n// 양방향 그래프\nconst setEdges = (edges, twoDimArr) => {\n  edges.forEach(edge => {\n    const [x, y, cost] = edge;\n    twoDimArr[x][y] = cost;\n    twoDimArr[y][x] = cost;\n  });\n};\n\n// 양방향 그래프\nconst dijkstra = (vertexs, edges, start) => {\n  const visited = setArray(vertexs, false);\n  const distance = setArray(vertexs, Infinity);\n  const adj = setTwoDimensionArr(vertexs, Infinity);\n\n  // 특정 시작 정점을 0으로 설정.\n  distance[start] = 0;\n  const queue = [start];\n  //인접 정점들 코스트.\n  setEdges(edges, adj);\n\n  while (visited.every(e !== true)) {\n    const startVertex = queue.shift();\n    // 최소 노드를 찾기 위한 min과 minVertex\n    let min = Infinity;\n    let minVertex = -1;\n    visited[startVertex] = true;\n    for (let i = 1; i &#x3C; adj.length; i++) {\n      if (startVertex === i) continue;\n      distance[i] = Math.min(\n        distance[i],\n        distance[startVertex] + adj[startVertex][i]\n      );\n      // 가장 작은 cost값을 찾기 위한 조건문.\n      if (distance[i] &#x3C; min) {\n        visited[i] = false;\n        min = distance;\n        minVertex = i;\n      }\n    }\n    if (minVertex === -1) break;\n    queue.push(minVertex);\n  }\n  return distance;\n};\n</code></pre>\n<p>하지만 이 코드의 경우, adj를 만들 때, 2차원 배열을 사용하므로 공간 복잡도가 n<em>n이다.\n그리고, 해당 정점에 인접한 값을 찾아야하기 때문에, n</em>n의 시간복잡도를 가진다.\n(정점은 1부터 시작한다고 가정.배열의 인덱스를 맞추기 위해 0 인덱스는 제외.)</p>\n<p>우선순위큐(heap자료구조)를 사용하면, heap은 이진트리로 만들고, 이진트리의 복잡도는 Nlog2 N(로그 2의 N)의 값을 가지기 때문에,<br>\n우선순위큐를 사용할 때, 시간복잡도가 더 줄어든다.</p>\n<h2>Min heap을 사용한 다익스트라 알고리즘.(단방향)</h2>\n<h3>Heap</h3>\n<pre><code class=\"language-js\">class Heap {\n  constructor() {\n    this.arr = [0];\n  }\n\n  add(value) {\n    this.arr.push(value);\n    this._heapify();\n  }\n\n  pop() {\n    if (this.size() === 0) return -1;\n    const temp = this.arr.pop();\n    const returnValue = this.arr[1];\n    if (this.size() === 0) return temp;\n    this.arr[1] = temp;\n    this._heapify2();\n    return returnValue;\n  }\n\n  size() {\n    return this.arr.length - 1;\n  }\n\n  _heapify() {\n    const heap = this.arr;\n    let child = heap.length - 1;\n    let parent = Math.floor(child / 2);\n    while (parent !== 0) {\n      if (heap[parent][1] &#x3C;= heap[child][1]) break;\n      const temp = heap[parent];\n      heap[parent] = heap[child];\n      heap[child] = temp;\n      child = parent;\n      parent = Math.floor(child / 2);\n    }\n  }\n  _heapify2() {\n    const heap = this.arr;\n    let parent = 1;\n    let left = parent * 2;\n    let right = parent * 2 + 1;\n\n    while (heap[left] !== undefined || heap[right] !== undefined) {\n      if (heap[right] === undefined) {\n        if (heap[left][1] > heap[parent][1]) break;\n        this._change(left, parent, heap);\n        break;\n      }\n      if (heap[left][1] &#x3C;= heap[right][1]) {\n        if (heap[left][1] > heap[parent][1]) break;\n        [parent, left, right] = this._change(left, parent, heap);\n      } else {\n        if (heap[right][1] > heap[parent]) break;\n        [parent, left, right] = this._change(right, parent, heap);\n      }\n    }\n  }\n\n  _change(child, parent, heap) {\n    const temp = heap[parent];\n    heap[parent] = heap[child];\n    heap[child] = temp;\n    parent = child;\n    const left = parent * 2;\n    const right = parent * 2 + 1;\n    return [parent, left, right];\n  }\n}\n\nmodule.exports = Heap;\n</code></pre>\n<h3>다익스트라 알고리즘</h3>\n<pre><code class=\"language-js\">const dijkstraHeap = (vertexs, edges, start) => {\n  const adj = Array(vertexs + 1);\n  edges.forEach(edge => {\n    if (!adj[edge[0]]) adj[edge[0]] = [];\n    adj[edge[0]].push([edge[1], edge[2]]);\n  });\n\n  const distance = setArray(vertexs, Infinity);\n\n  const heap = new Heap();\n  let startVertex = [start, 0];\n  heap.add(startVertex);\n  distance[start] = 0;\n\n  while (heap.size()) {\n    const [index, value] = heap.pop();\n    if (!adj[index]) continue;\n    if (distance[index] &#x3C; value) continue;\n    adj[index].forEach(edge => {\n      const [vertex, value] = edge;\n      if (distance[vertex] &#x3C;= distance[index] + value) return;\n      distance[vertex] = distance[index] + value;\n      heap.add([vertex, distance[vertex]]);\n    });\n  }\n  return distance;\n};\n</code></pre>","frontmatter":{"title":"다익스트라 알고리즘","date":"2020년 08월 09일, 14:00"}}},"pageContext":{"slug":"/10/post92/","previous":{"fields":{"slug":"/10/post91/"},"frontmatter":{"title":"자바스크립트 Object,Map,hashMap","path":"/posts/91"}},"next":{"fields":{"slug":"/10/post93/"},"frontmatter":{"title":"[백준] 1753번 최단경로","path":"/posts/93"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}