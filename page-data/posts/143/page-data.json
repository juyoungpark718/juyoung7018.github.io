{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/143/","result":{"data":{"markdownRemark":{"html":"<h2>리액티브 프로그래밍</h2>\n<p><a href=\"http://reactivex.io/\">ReactiveX</a>으로 공식 홈페이지에서 표현은</p>\n<pre>\n  ReactiveX is a combination of the best ideas \n    from the Observer pattern, the Iterator pattern, and functional programming\n\n  ReactiveX is a library \n    for composing asynchronous and event-based programs by using observable sequences.\n</pre>\n<p>옵저버 패턴, 이터레이터 패턴 그리고 함수형 프로그래밍을 조합한 프로그래밍이라고 생각하면 될 것 같다. 그리고,<br>\n여기에 비동기적, 이벤트 기반이다.</p>\n<p>리액티브 프로그래밍은 비동이 이벤트를 처리하기 위해서 다음과 같은 객체들을 이용해서 처리한다.</p>\n<ul>\n<li>Observable</li>\n<li>Observer</li>\n<li>Subscription</li>\n<li>Operators</li>\n<li>Subject</li>\n<li>Schedulers</li>\n</ul>\n<h3>Observable</h3>\n<ul>\n<li>비동기 collections</li>\n<li>Observables are lazy Push collections of multiple values.</li>\n</ul>\n<p>pull vs push</p>\n<ul>\n<li>pull\n<ul>\n<li>우리가 일반적으로 아는 코드</li>\n<li>Array 등 iteratable한 객체</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">const arr = [1,2,3,4,5];\n\nfor(let i of arr){\n\tconsole.log(i);\n}\n</code></pre>\n<ul>\n<li>push\n<ul>\n<li>비동기</li>\n<li>promise</li>\n<li>observable</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">const observable = new Observable(subscriber => {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  setTimeout(() => {\n    subscriber.next(4);\n    subscriber.complete();\n  }, 1000);\n});\n</code></pre>\n<h3>Operator</h3>\n<ul>\n<li>rxjs에서 많은 유용한 operator</li>\n<li>순수함수이며 함수형 프로그래밍을 가능하게 해줌</li>\n<li>ex) map, flatmap, switchmap etc..</li>\n</ul>\n<h3>Subscription</h3>\n<ul>\n<li>보통 Observable.subscribe 후 객체</li>\n<li>사용 후 버릴 수 있는 객체(직역하면?)</li>\n<li>A Subscription is an object that represents a disposable resource, usually the execution of an Observable.</li>\n</ul>\n<pre><code class=\"language-jsx\">const observable = interval(1000);\nconst subscription = observable.subscribe(x => console.log(x));\n// Later:\n// This cancels the ongoing Observable execution which\n// was started by calling subscribe with an Observer.\nsubscription.unsubscribe();\n</code></pre>\n<h3>Subject</h3>\n<ul>\n<li>\n<p>Observable의 특별한 타입 정도라고 보면 된다.</p>\n</li>\n<li>\n<p>Observable은 unicast(1:1)이지만 subject는 multicast</p>\n<pre><code class=\"language-jsx\">const subject = new Subject();\n \nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`)\n});\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`)\n});\n \nsubject.next(1);\nsubject.next(2);\n</code></pre>\n</li>\n<li>\n<p>subject는 observable, observer</p>\n<pre><code class=\"language-jsx\">subject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`)\n});\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`)\n});\n \nconst observable = from([1, 2, 3]);\n \nobservable.subscribe(subject);\n</code></pre>\n</li>\n</ul>\n<h3>Scheduler</h3>\n<ul>\n<li>동시성을 제어하는 디스패처</li>\n<li>연산이 발생하는 시점을 조정 가능</li>\n<li>ex) setTimeout, requestAnimationFrame, micro-task-queue</li>\n</ul>\n<pre><code class=\"language-js\">// Schedules work with setInterval. Use this for time-based operations.\nlet observable = new Observable((proxyObserver) => {\n  proxyObserver.next(1);\n  proxyObserver.next(2);\n  proxyObserver.next(3);\n  proxyObserver.complete();\n}).pipe(\n  observeOn(asyncScheduler)\n);\n \nlet finalObserver = {\n  next(x) {\n    console.log('got value ' + x)\n  },\n  error(err) {\n    console.error('something wrong occurred: ' + err);\n  },\n  complete() {\n     console.log('done');\n  }\n};\n \nconsole.log('just before subscribe');\nobservable.subscribe(finalObserver);\nconsole.log('just after subscribe');\n</code></pre>\n<pre>\n실행 결과\njust before subscribe\njust after subscribe\ngot value 1\ngot value 2\ngot value 3\ndone\n</pre>","frontmatter":{"title":"[RxJS] ReactiveX javascript","date":"2021년 06월 02일, 21:30"}}},"pageContext":{"slug":"/15/post143/","previous":{"fields":{"slug":"/15/post142/"},"frontmatter":{"title":"[아티클럽] 올해 버려야 할 타입스크립트 나쁜 버릇 10가지를 읽고","path":"/posts/142"}},"next":{"fields":{"slug":"/15/post144/"},"frontmatter":{"title":"[Cypress] 자바스크립트 e2e 테스트 프레임워크","path":"/posts/144"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}