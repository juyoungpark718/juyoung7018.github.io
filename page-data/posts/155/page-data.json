{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/155/","result":{"data":{"markdownRemark":{"html":"<h3>영속성 컨텍스트란?</h3>\n<p>JPA(Java Persistence API)에서 사용되는 용어로 <strong>엔티티를 영구 저장하는 환경</strong>이라는 뜻을 가지고 있다.\nDB에 저장하는 것이 아니라 영속성 컨텍스트를 통해서 엔티티를 영속화한다는 뜻.</p>\n<p>영속화란?\n영속성 컨텍스트에 관리되는 상태로 만드는 것</p>\n<p>예를 들면,</p>\n<p>객체를 생성한 상태 -> 트랜잭션 시작 -> 엔티티 매니저를 통해 persist(영속화) <em>디비에 저장 X</em> -> 트랙잭션 commit -> 영속화 된 객체가 DB로 쿼리가 날라가게 됨.</p>\n<p>왜 사용하는 것일까?</p>\n<ul>\n<li>1차 캐시 : 영속화 한 뒤에 find를 하게되면 DB가 아니라 1차캐시 값을 조회</li>\n<li>동일성 보장 : 1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공</li>\n<li>트랜잭션을 지원하는 쓰기 지연 : persist한 경우 insert를 날리지 않고 쓰기지연 SQL 저장소에 쌓아논 후 commit을 했을 때 insert를 날린다.</li>\n<li>변경감지(Dirty Checking)</li>\n<li>플러시(flush) : 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화</li>\n</ul>\n<p>JPA는 자바 진영에서 ORM(Object-Relational-Mapping) 기술 표준으로 사용되는 인터페이스의 모음. 즉, 실제로 구현된것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크. JPA를 구현한 대표적인 오픈소스로는 Hibernate가 있다.</p>\n<p>\u001f\n참고)</p>\n<ul>\n<li><a href=\"https://tall-developer.tistory.com/7\">https://tall-developer.tistory.com/7</a></li>\n</ul>\n<h3><strong>포트와 어댑터</strong>(육각형 아키텍쳐) 패턴</h3>\n<ul>\n<li>포트\n<ul>\n<li>인프라가 할 수 있는 일을 정의한 인터페이스</li>\n<li>애플리케이션은 인터페이스를 통해 다른 대상과 정보를 교환 가능</li>\n<li>인프라의 구현과 완전히 분리</li>\n</ul>\n</li>\n<li>어댑터\n<ul>\n<li>포트의 구현체</li>\n<li>인프라가 어떻게 동작하는지, 어떻게 통신하는지 알고 있음</li>\n<li>ex) 데이터베이스나 웹 서비스 등과 통신하는 일을 함</li>\n</ul>\n</li>\n</ul>\n<p>포트와 어댑터를 사용하면,</p>\n<p>포트는 인프라가 할 수 있는 일을 정의한 인터페이스이다. 애플리케이션은 인터페이스를 통해 다른 대상과 정보를 주고받을 수 있다. 포트는 인프라의 구현과 완전히 분리되어 있다.</p>\n<p>반면에, 어댑터는 인프라에 매우 가까이 있다. 어댑터는 포트의 구현체로서 데이터베이스나 웹 서비스 등과 통신하는 일을 한다. 어댑터는 인프라가 어떻게 동작하는지, 어떻게 통신 하는지를 알고 있다.</p>\n<p>장점으로는,</p>\n<p>외부 어댑터의 구현이 바뀌어도 내부 서비스에는 영향을 받지 않고,</p>\n<p>포트는 인터페이스이다보니 테스트 하는 경우 스텁이나 목으로 대체하여 테스트를 비즈니스 규칙에 집중하여 테스트 가능하다.</p>\n<p>하지만, 스텁이나 목으로 대체가 가능한 대신 애플리케이션 코드뿐만 아니라 어댑터 코드도 테스트 해야한다.</p>\n<h3>Nextra</h3>\n<p>Nestra는 Next.js를 기반으로 하는 프레임워크이다.(Next.js Static-site-generator)\n콘텐츠 중심으로 웹사이트를 구성할 수 있는데, Markdown 기반 콘텐츠(mdx)를 쉽게 생성할 수 있다.</p>\n<p>기본으로 제공하는 테마는 아래 2가지를 지원한다.</p>\n<ul>\n<li>Documentation Theme(<a href=\"https://nextra-docs-template.vercel.app/\">데모</a>)</li>\n<li>Blog Theme</li>\n</ul>\n<p>문서 테마는 아마 라이브러리 문서들의 형식에서 자주 볼 수 있다.\n검색기능이나, 다크모드, I18n, syntax highlighting 등 손쉽게 문서를 만들 수 있어서 자주 애용하나보다.</p>\n<p>간단하고 깔끔해서 사용하기 좋아보인다.</p>\n<p>참고)</p>\n<ul>\n<li><a href=\"https://nextra.site/\">https://nextra.site/</a></li>\n<li>mdx\n<ul>\n<li>markdown content에서 jsx 문법을 사용할 수 있게 함</li>\n</ul>\n</li>\n</ul>\n<h3>Awaited  유틸리티 타입</h3>\n<p>이 유틸리티 타입은 비동기 함수의 반환값인 Promise를 없애고 타입을 추론하게 도와준다.</p>\n<p>ex)</p>\n<pre><code class=\"language-ts\">type A = Awaited&#x3C;Promise&#x3C;string>>;\n// type A = string\n\ntype B = Awaited&#x3C;Promise&#x3C;Promise&#x3C;number>>>;\n// type B = number\n\ntype C = Awaited&#x3C;boolean | Promise&#x3C;number>>; \n// type C = number | boolean\n</code></pre>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html#awaitedtype\">타입스크립트 공식 문서</a></li>\n</ul>\n<h3>Rollup Playground</h3>\n<p>Rollup에서 코드가 어떻게 변환되는지 볼 수 있는 playground를 제공한다.(<a href=\"https://rollupjs.org/repl\">링크</a>)</p>\n<p>출력물의 format(es, amd)도 선택해서 볼 수 있고, treeshakse의 여부를 판단할 수 있다.</p>\n<p>작성한 코드가 treeshaking이 지원하는지 확인하고 싶으면 간단하게 해보는 것도 좋을 것 같다.</p>\n<h3>tc39가 뭘까?</h3>\n<ul>\n<li>Technial Committee 39</li>\n<li>Ecma 인터내셔널의 여러 기술 위원회 중 ECMA-262 명세 관리를 하는 위원회</li>\n<li><a href=\"https://ahnheejong.name/articles/ecmascript-tc39/\">참고</a> ^0j2wr8</li>\n</ul>\n<h3>딥링크</h3>\n<p>특정 주소 혹은 값을 입력하면 앱이 실행되거나 앱 내 특정화면으로 이동시키는 기능</p>\n<p>딥링크에서는 총 2가지 방식으로 구분된다.</p>\n<ul>\n<li>URI 스킴 방식 : 앱에 URI 스킴(url scheme) 값을 등록하여 사용</li>\n<li>도메인 주소를 이용한 딥링크 사용\n<ul>\n<li>Android - 앱링크(App Link)</li>\n<li>iOS - 유니버셜링크(Universal Link)</li>\n</ul>\n</li>\n</ul>\n<p><strong>URI 스킴</strong></p>\n<ul>\n<li>URI스킴을 이용한 딥링크는 앱에 Scheme값을 등록하는 형태로 앱을 구분</li>\n<li>개발 시에 효율적인 앱 오픈을 위해서 ==자체적으로 개발사에서 자신들만의 값으로 등록==</li>\n</ul>\n<p>URI 스킴은 두 개의 요소로 구성된다.</p>\n<ul>\n<li>Scheme://Path\n<ul>\n<li>Scheme : 앱을 특정하는 값</li>\n<li>Path : 앱 내 페이지를 특정하는 값</li>\n<li>ex)\n<ul>\n<li>kakaotalk://</li>\n<li>kakaotalk://signup</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>문제점이 있는데, 앱 수가 증가하면서 앱 스킴 값이 중복되어 개발자는 고유한 값인지 알 수 없는 문제가 생겼다.</p>\n<p>이를 해결하기 위해서 ==도메인 주소를 이용한 딥링크(App, Universal Link)==가 나왔다.</p>\n<p>웹 사이트 주소는 모두 고유의 값을 가지고 있기 때문에 해당 도메인 주소를 사용하면 무조건 고유한 값이기 때문에 URI 스킴의 중복문제를 해결할 수 있다.</p>\n<p>근데, 한계가 있는데 <em>모든 앱에서 유니버셜 링크와 앱링크 오픈을 지원하지 않는다</em>고 한다.</p>\n<p><strong>URI, URL</strong></p>\n<p><strong>URI(Uniform Resource Identifier)</strong> 는 통합 자원 식별자다.\n인터넷에 있는 자원을 뜻하는 유일한 주소를 말한다.</p>\n<p>URI안에 URN, URL이 포함되는데,</p>\n<ul>\n<li>\n<p>URL</p>\n<ul>\n<li>Uniform Resource Locator</li>\n<li>웹 사이트 서버들에 있는 ==파일의 위치==(리소스의 위치)</li>\n</ul>\n</li>\n<li>\n<p>URN</p>\n<ul>\n<li>Uniform Resource Name</li>\n<li>위치와 관계 없이 ==리소스의 이름값만 이용해서 접근==하는 방식</li>\n</ul>\n</li>\n<li>\n<p>참고</p>\n<ul>\n<li><a href=\"https://help.dfinery.io/hc/ko/articles/360039757433-%EB%94%A5%EB%A7%81%ED%81%AC-Deeplink-URI%EC%8A%A4%ED%82%B4-%EC%9C%A0%EB%8B%88%EB%B2%84%EC%85%9C-%EB%A7%81%ED%81%AC-%EC%95%B1%EB%A7%81%ED%81%AC-%EA%B5%AC%EB%B6%84%EA%B3%BC-%EC%9D%B4%ED%95%B4\">딥링크(Deeplink) : URI스킴, 유니버셜 링크, 앱링크 구분과 이해</a></li>\n<li><a href=\"https://abcdqbbq.tistory.com/43\">URI과 URL 비교</a></li>\n</ul>\n</li>\n</ul>\n<h3>Storybook interaction-testing</h3>\n<p>팀원 분께서 styled-component를 버전 업데이트 하면서 회귀 테스트를 작성해주셨는데</p>\n<p>테스트 환경을 dom을 모의하고 있는 jsdom에서 css파일을 읽어오지 못해서\n테스트가 모두 깨져 e2e test를 진행하시려고 했고 우리 레포에는 e2e test 툴이 없어서 storybook을 이용해서 테스트를 작성해주셨다.</p>\n<p>기본적으로 아래 3개의 패키지를 설치해서 테스트를 구성하면 된다.</p>\n<ul>\n<li><code>@storybook/testing-library</code></li>\n<li><code>@storybook/jest</code></li>\n<li><code>@storybook/addon-interactions</code></li>\n</ul>\n<p>ex)</p>\n<pre><code class=\"language-ts\">import type { Meta, StoryObj } from '@storybook/react';\n\nimport { within, userEvent } from '@storybook/testing-library';\n\nimport { expect } from '@storybook/jest';\n\n// ... 생략\n\nexport const FilledForm: Story = {\n  play: async ({ canvasElement }) => {\n    const canvas = within(canvasElement);\n\n    // 👇 Simulate interactions with the component\n    await userEvent.type(canvas.getByTestId('email'), 'email@provider.com');\n\n    await userEvent.type(canvas.getByTestId('password'), 'a-random-password');\n\n    // See https://storybook.js.org/docs/react/essentials/actions#automatically-matching-args to learn how to setup logging in the Actions panel\n    await userEvent.click(canvas.getByRole('button'));\n\n    // 👇 Assert DOM structure\n    await expect(\n      canvas.getByText(\n        'Everything is perfect. Your account is ready and we should probably get you started!'\n      )\n    ).toBeInTheDocument();\n  },\n};\n</code></pre>\n<p>참고)</p>\n<ul>\n<li><a href=\"https://storybook.js.org/docs/react/writing-tests/interaction-testing\">https://storybook.js.org/docs/react/writing-tests/interaction-testing</a></li>\n</ul>","frontmatter":{"title":"7월 4주차","date":"2023년 07월 29일, 05:44"}}},"pageContext":{"slug":"/16/post155/","previous":{"fields":{"slug":"/16/post154/"},"frontmatter":{"title":"7월 3주차","path":"/posts/154"}},"next":null}},"staticQueryHashes":["3649515864"],"slicesMap":{}}