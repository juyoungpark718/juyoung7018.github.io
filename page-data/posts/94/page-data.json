{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/94/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>연결 요소 개수</h2>\n<h3>문제 설명</h3>\n<p>방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.</p>\n<p><strong><em>입력</em></strong></p>\n<p>첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.</p>\n</blockquote>\n<h3>문제 풀이</h3>\n<ol>\n<li>해당 정점으로 부터 연결된 정점을 다 살펴봐야한다. -> 2차원 배열을 이용해서 표시.(connected배열)</li>\n<li>방문된 정점이면 continue;</li>\n<li>그렇지 않다면, 해당 정점으로부터 연결되어 갈 수 있는 정점을 모두 탐색. queue가 비어지는 경우 count++(그룹의 수).</li>\n</ol>\n<pre><code class=\"language-js\">const fs = require(\"fs\");\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n// const input = fs.readFileSync(\"./stdin\").toString().trim().split(\"\\n\");\nconst [vertexLen, edgeLen] = input[0].split(\" \").map(e => +e);\nconst edges = input.slice(1).map(e => e.split(\" \").map(el => +el));\n\nconst connected = Array(vertexLen + 1)\n  .fill(0)\n  .map(e => Array());\n\nedges.forEach(e => {\n  connected[e[0]].push(e[1]);\n  connected[e[1]].push(e[0]);\n});\n\nconst visited = Array(vertexLen + 1).fill(false);\n\nlet count = 0;\nfor (let i = 1; i &#x3C; vertexLen + 1; i++) {\n  if (visited[i] === true) continue;\n  const queue = [i];\n  while (queue.length) {\n    const start = queue.pop();\n    if (visited[start] === true) continue;\n    visited[start] = true;\n    queue.push(...connected[start]);\n  }\n  count++;\n}\n\nconsole.log(count);\n</code></pre>","frontmatter":{"title":"[백준] 11724번 연결요소개수","date":"2020년 08월 17일, 12:00"}}},"pageContext":{"slug":"/10/post94/","previous":{"fields":{"slug":"/10/post93/"},"frontmatter":{"title":"[백준] 1753번 최단경로","path":"/posts/93"}},"next":{"fields":{"slug":"/10/post95/"},"frontmatter":{"title":"[프로그래머스] 레벨4 (level4) 지형이동","path":"/posts/95"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}