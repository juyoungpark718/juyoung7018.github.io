{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/153/","result":{"data":{"markdownRemark":{"html":"<h3>소개</h3>\n<p>Node.js server-side application 프레임워크이다.</p>\n<blockquote>\n<p>Nest (NestJS) is a framework for building efficient, scalable Node.js server-side applications.</p>\n</blockquote>\n<p>TypeScript를 지원하고, OOP(Object Oriented Programming), FP(Functional Programming), FRP(Functional Reactive Programming)의 요소를 결합해둔 프레임워크라고한다.</p>\n<p>NestJS는 out-of-the-box 애플리케이션 아키텍쳐를 제공하고 있다.\n(out-of-the-box: 기본적으로 모든 환경을 제공해줘서 사용자가 따로 커스텀할 필요 없이 사용 가능)\n그래서 개발자나 팀이 사용하는 경우에 아래와 같은 이점이 있다고 한다.</p>\n<ul>\n<li>테스트가 쉬움</li>\n<li>확장가능함</li>\n<li>느슨한 관계</li>\n<li>쉬운 유지보수</li>\n</ul>\n<p>아키텍쳐는 Angular에 영감을 많이 받았다고 한다.</p>\n<h3>구조</h3>\n<h4>Controllers</h4>\n<p>Controller는 요청과 응답을 다룬다.\n라우팅 알고리즘을 통해 어떤 Controller가 응답을 받을지 결정한다.\nController는 하나 이상의 route를 가지고 있으며 route들은 각각 다른 행동을 한다.</p>\n<pre><code class=\"language-typescript\">import { Controller, Get } from '@nestjs/common';\n\n@Controller('cats')\nexport class CatsController {\n  @Get()\n  findAll(): string {\n    return 'This action returns all cats';\n  }\n}\n</code></pre>\n<p>기본 컨트롤러를 정의하기 위해서는 <code>@Controller</code>  데코레이터를 사용해야한다.\n<code>@Controller</code>는 route할 path의 prefix나 sub-domain같은 값들을 받을 수 있다.</p>\n<p>Controller의 각 메소드는 HTTP 요청을 처리하고 응답을 리턴한다.\nNest에서 응답을 처리하는 방법은 객체, 배열인 경우에는 JSON으로 자동으로 처리하고, 원시값인 경우에는 JSON으로 처리하지 않고 반환한다. 값을 반환하기만 하면 Nest가 알아서 처리해준다.</p>\n<p>요청을 받는 메소드에 데코레이터를 통해 여러가지 정보들을 설정해줄 수 있다.</p>\n<ul>\n<li>HTTP Methods\n<ul>\n<li>HTTP 메소드를 지정할 수 있다.</li>\n<li>ex) <code>@Get</code> , <code>@Post</code> 등등</li>\n</ul>\n</li>\n<li>Headers\n<ul>\n<li>응답 헤더를 설정할 수 있다.</li>\n<li>ex) <code>@Header('Cache Control', 'none')</code></li>\n</ul>\n</li>\n<li>Status Code\n<ul>\n<li>응답 HTTP 코드를 설정할 수 있다.</li>\n<li>ex) <code>@Redirect('https://nestjs.com', 301)</code></li>\n</ul>\n</li>\n<li>Redirection\n<ul>\n<li>리다이렉트 url을 설정할 수 있다.</li>\n<li>ex) <code>@Redirect('https://docs.nestjs.com', 302)</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>Request Object</strong>\nRequest 객체는 HTTP 요청에 관한 속성들을 가지고 있는데, 데코레이터를  사용하면 속성을 가져올 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>decorator</th>\n<th>plain platform-specific objects</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@Request(), @Req()</code></td>\n<td><code>req</code></td>\n</tr>\n<tr>\n<td><code>@Response(), @Res() *</code></td>\n<td><code>res</code></td>\n</tr>\n<tr>\n<td><code>@Next()</code></td>\n<td><code>next</code></td>\n</tr>\n<tr>\n<td><code>@Session()</code></td>\n<td><code>req.session</code></td>\n</tr>\n<tr>\n<td><code>@Param(key?: string)</code></td>\n<td><code>req.params</code> / <code>req.params[key]</code></td>\n</tr>\n<tr>\n<td><code>@Query(key?: string)</code></td>\n<td><code>req.query</code> / <code>req.query[key]</code></td>\n</tr>\n<tr>\n<td><code>@Headers(name?: string)</code></td>\n<td><code>req.headers</code> / <code>req.headers[name]</code></td>\n</tr>\n<tr>\n<td><code>@Ip()</code></td>\n<td><code>req.ip</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>Route parameters</strong></p>\n<p>경로에 parameter를 넣어 동적으로 값을 가져오는 경우에 아래와 같이 할 수 있다.</p>\n<pre><code class=\"language-ts\">import { Controller, Get } from '@nestjs/common';\n\n@Controller('cats')\nexport class CatsController {\n\t@Get(':id')\n\tfindOne(@Param() params): string {\n\t\tconsole.log(params.id);\n\t\treturn `This action returns a #${params.id} cat`;\n\t}\n}\n</code></pre>\n<p>또는</p>\n<pre><code class=\"language-typescript\">@Get(':id')\nfindOne(@Param('id') id: string): string {\n  return `This action returns a #${id} cat`;\n}\n</code></pre>\n<p><strong>Request payloads</strong>\nPOST 메소드에서 클라이언트가 보낸 payload를 @Body decorator를 이용해서 처리할 수 있다.</p>\n<p>요청을 처리하기 위해서는 DTO를 만들어야하는데 Nest는 TypeScript의 interface나 간단한 class를 사용한다.</p>\n<blockquote>\n<p>Data Transfer Object(DTO)\n계층 간 데이터 교환을 하기 위한 객체로 로직을 가지지 않고 Getter, Setter만 존재하는 순수한 데이터 객체</p>\n</blockquote>\n<p>2가지 방법이 있지만, Class를 사용하는 것을 더 추천하고 있는데 Class는 ES6 표준이고 TypeScript가 컴파일 될 때 보존되기 때문이다. Nest에는 Pipes 같은 기능이 런타임 때 변수의 메타타입에 접근할 때 가능하게 한다고 한다.</p>\n<blockquote>\n<p>Pipes\nPipeTransform을 구현하는  @Injectable() 데코레이터이다.\n입력한 데이터를 원하는 타입으로 변경하는 경우나 데이터에 대한 검증을 하는 경우에 사용한다.</p>\n</blockquote>\n<p><em>create-cat.dto.ts</em></p>\n<pre><code class=\"language-typescript\">export class CreateCatDto {\n  name: string;\n  age: number;\n  breed: string;\n}\n</code></pre>\n<p><em>cats.controller.ts</em></p>\n<pre><code class=\"language-typescript\">@Post()\nasync create(@Body() createCatDto: CreateCatDto) {\n  return 'This action adds a new cat';\n}\n</code></pre>\n<p><strong>Module에 등록</strong></p>\n<p>Controller는 항상 Module에 속해야하며 <code>@Module</code> 데코레이터 안에 배열에 포함되어야한다.</p>\n<p><em>app.module.ts</em></p>\n<pre><code class=\"language-typescript\">import { Module } from '@nestjs/common';\nimport { CatsController } from './cats/cats.controller';\n\n@Module({\n  controllers: [CatsController],\n})\nexport class AppModule {}\n</code></pre>\n<h4>Providers</h4>\n<p>Provider는 NestJS의 기본 개념이다.\nNest에서는 많은 클래스들이 Provider로 다루어지는데, 여기에는</p>\n<ul>\n<li>Services</li>\n<li>Repositories</li>\n<li>Factories</li>\n<li>Helpers</li>\n</ul>\n<p>같은 클래스들이 있다.</p>\n<p>Provider의 기본 아이디어는 Provider가 의존성 주입이 되는 것이다. 이때, 의존성은 Nest runtime에서 주입해준다.</p>\n<p>Controller는 HTTP request를 다루고, 복잡한 일을 Provider에 위임한다.\nProvider는 class로 작성되고 Module안에서 <code>providers</code>에 넣어줘야한다.</p>\n<p>Provider는 <code>@Injectable</code> 데코레이터를 사용한다.\n이 데코레이터는 Provider가 Nest IoC 컨테이너에서 관리할 수 있는 클래스인 것을 나타내는 메타데이터를 지정해준다.</p>\n<p>ex)\n<em>cats.service.ts</em></p>\n<pre><code class=\"language-typescript\">import { Injectable } from '@nestjs/common';\nimport { Cat } from './interfaces/cat.interface';\n\n@Injectable()\nexport class CatsService {\n  private readonly cats: Cat[] = [];\n\n  create(cat: Cat) {\n    this.cats.push(cat);\n  }\n\n  findAll(): Cat[] {\n    return this.cats;\n  }\n}\n</code></pre>\n<p><em>interfaces/cat.interface.ts</em></p>\n<pre><code class=\"language-typescript\">export interface Cat {\n  name: string;\n  age: number;\n  breed: string;\n}\n</code></pre>\n<p><em>cats.controller.ts</em></p>\n<pre><code class=\"language-typescript\">import { Controller, Get, Post, Body } from '@nestjs/common';\nimport { CreateCatDto } from './dto/create-cat.dto';\nimport { CatsService } from './cats.service';\nimport { Cat } from './interfaces/cat.interface';\n\n@Controller('cats')\nexport class CatsController {\n  constructor(private catsService: CatsService) {}\n\n  @Post()\n  async create(@Body() createCatDto: CreateCatDto) {\n    this.catsService.create(createCatDto);\n  }\n\n  @Get()\n  async findAll(): Promise&#x3C;Cat[]> {\n    return this.catsService.findAll();\n  }\n}\n</code></pre>\n<p>Class의 생성자에서 CatsService가 주입됨.</p>\n<p><strong>Module에 등록</strong></p>\n<p>Controller와 마찬가지로 Provider도 Module에 등록해줘야한다.</p>\n<p><em>app.module.ts</em></p>\n<pre><code class=\"language-typescript\">\nimport { Module } from '@nestjs/common';\nimport { CatsController } from './cats/cats.controller';\nimport { CatsService } from './cats/cats.service';\n\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n})\nexport class AppModule {}\n</code></pre>\n<h4>Modules</h4>\n<p>Module은 @Module 데코레이터를 사용한 클래스이다.\n@Module 데코레이터는 Nest가 Module을 애플리케이션 구조를 구성하는데 사용하는 메타데이터를 준다.</p>\n<p>각 어플리케이션은 적어도 1개의 Module(Root Module)을 가진다.\nRoot Module은 Nest가 애플리케이션 그래프를 만드는 시작점이다.\n앱의 크기가 작으면 Root Module만 존재할 수 있지만, 여러 개를 사용하여 밀접하게 관련된 기능들을 캡슐화하여 사용하는 것을 Nest에서는 추천한다.</p>\n<p>@Module 데코레이터는 객체를 받는데, 객체의 속성은 아래와 같다.</p>\n<table>\n<thead>\n<tr>\n<th>properties</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>providers</td>\n<td>Module에서 공유될 수 있는 providers</td>\n</tr>\n<tr>\n<td>controllers</td>\n<td>인스턴스화 되어야하는 모듈에 정의된 Controllers</td>\n</tr>\n<tr>\n<td>imports</td>\n<td>해당 모듈에서 필요한 providers를 exports하는 Modules</td>\n</tr>\n<tr>\n<td>exports</td>\n<td>providers의 subset으로 다른 모듈에서 사용할 수 있는 providers</td>\n</tr>\n</tbody>\n</table>\n<p>Module은 기본적으로 providers를 캡슐화하기 때문에 exports를 하는 것을 Module의 public interface 혹은 API라고 생각해도 된다.</p>","frontmatter":{"title":"Nestjs","date":"2022년 12월 19일, 04:00"}}},"pageContext":{"slug":"/16/post153/","previous":{"fields":{"slug":"/16/post152/"},"frontmatter":{"title":"Webpack 코드 스플리팅","path":"/posts/152"}},"next":null}},"staticQueryHashes":["3649515864"],"slicesMap":{}}