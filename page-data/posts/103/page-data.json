{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/103/","result":{"data":{"markdownRemark":{"html":"<h3>원시값에 대한 메소드들이 존재할 수 있는 이유?</h3>\n<p>우리는 string이나 number를 할당한 변수에 여러가지 메소드를 사용할 수 있다.</p>\n<p>이때, 원시값을 가지는 특별한 객체를 만들었다가 객체에서 메소드를 실행하고 새로운 값이 반환되는 것이다.</p>\n<h3>숫자형에서의 메소드들</h3>\n<p><code>num.toString(base)</code></p>\n<ul>\n<li>base에 바꿀 진수를 넣으면 된다.(기본값은 10, 2~36까지 가능)</li>\n</ul>\n<p><strong>부정확한 계산</strong></p>\n<p>숫자는 내부적으로 <code>64비트 형식 IEEE-754</code>으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요합니다. 64비트 중 <code>52비트는 숫자를 저장</code>하는 데 사용되고, <code>11비트는 소수점 위치를(정수는 0)</code>, <code>1비트는 부호를 저장</code>하는 데 사용됩니다.</p>\n<p><strong>이유</strong></p>\n<p>숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장됩니다. 그런데 10진법을 사용하면 쉽게 표현할 수 있는 <code>0.1</code>, <code>0.2</code> 같은 분수는 이진법으로 표현하면 무한 소수가 됩니다.</p>\n<p><code>0.1</code>은 1을 10으로 나눈 수인 <code>1/10</code>입니다. 10진법을 사용하면 이러한 숫자를 쉽게 표현할 수 있죠. <code>1/10</code>과 <code>1/3</code>을 비교해봅시다. <code>1/3</code>은 무한 소수 <code>0.33333(3)</code>이 됩니다.</p>\n<p>이렇게 <code>10</code>의 거듭제곱으로 나눈 값은 10진법에서 잘 동작하지만 <code>3</code>으로 나누게 되면 10진법에서 제대로 동작하지 않습니다. 같은 이유로 2진법 체계에서 <code>2</code>의 거듭제곱으로 나눈 값은 잘 동작하지만 <code>1/10</code>같이 <code>2</code>의 거듭제곱이 아닌 값으로 나누게 되면 무한 소수가 되어버립니다.</p>\n<p>10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용해 <em>0.1</em> 또는 <em>0.2</em>를 <strong>정확하게</strong> 저장하는 방법은 없습니다.</p>\n<p>IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결합니다. 그런데 반올림 규칙을 적용하면 발생하는 '작은 정밀도 손실’을 우리가 볼 수는 없지만 실제로 손실은 발생합니다.</p>\n<h3>배열의 메서드</h3>\n<ul>\n<li>reduceRight\n<ul>\n<li>reduce와 반대로 배열의 마지막 원소부터 실행</li>\n</ul>\n</li>\n<li>find, filter, map 의 경우 두 번째 인자로 bind할 대상을 넘겨줄 수 있다.</li>\n</ul>\n<h3>Object</h3>\n<p><code>Object.entries</code> 함수는 객체를 맵으로 바꿔줌.</p>\n<p><code>Object.fromEntries</code> 함수는 맵을 객체로 바꿔줌.</p>\n<pre><code class=\"language-jsx\">const m = new Map([\n    [\"a\",1],\n    [\"b\",2],\n    [\"c\",3]\n]);\n\nconsole.log(m.get(\"a\")); // 1\n\nconst obj = {\n    a:1,\n    b:2,\n    c:3\n};\n\nconst m2 = new Map(Object.entries(obj));\nconsole.log(m2.get(\"a\")); // 1\n\nconst obj2 = Object.fromEntries(m2.entries());\nconsole.log(obj2); // { a: 1, b: 2, c: 3 }\n</code></pre>\n<h3>Weak map과 weak set</h3>\n<p>자바스크립트의 가비지 컬렉터는 해당 값으로 도달 가능하면 메모리에서 삭제하지 않는다.</p>\n<p>그래서 Map, set의 원소로 객체를 저장하게 되면 객체를 null로 바꿔준다 하더라도 삭제가 일어나지 않는다.</p>\n<p>하지만, weak map,set은 객체만 저장할 수 있고 객체의 값이 null이 되면 삭제해준다.</p>\n<h3>Json.stringify</h3>\n<p>순환 참조가 있는 object에는 사용 불가</p>\n<pre><code class=\"language-jsx\">let room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup references room\n};\n\nroom.occupiedBy = meetup; // room references meetup\n\nalert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );\n/*\n{\n  \"title\":\"Conference\",\n  \"participants\":[{\"name\":\"John\"},{\"name\":\"Alice\"}],\n  \"place\":{\"number\":23}\n}\n*/\n</code></pre>\n<p>두 번째 인자로 뽑고 싶은 key를 전달하면 해당 값만 뽑힌다.</p>\n<p>세 번째 인자는 space의 유무이다(가독성을 높여줌)</p>\n<h3>Json.parse</h3>\n<p>두 번째 인자로 reviver를 사용할 수 있다.</p>\n<pre><code class=\"language-jsx\">let str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n\nlet meetup = JSON.parse(str, function(key, value) {\n  if (key == 'date') return new Date(value);\n  return value;\n});\n\nconsole.log( meetup.date.getDate() ); // 30\n</code></pre>\n<h3>참고</h3>\n<p><a href=\"https://ko.javascript.info/object-methods\">https://ko.javascript.info/object-methods</a></p>","frontmatter":{"title":"[자바스크립트] 자료형에 대한 메소드","date":"2020년 10월 26일, 23:17"}}},"pageContext":{"slug":"/11/post103/","previous":{"fields":{"slug":"/11/post102/"},"frontmatter":{"title":"[자바스크립트] 객체","path":"/posts/102"}},"next":{"fields":{"slug":"/11/post104/"},"frontmatter":{"title":"객체지향 프로그래밍","path":"/posts/104"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}