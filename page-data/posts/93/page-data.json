{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/93/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>최단경로</h2>\n<h3>문제 설명</h3>\n<p>방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.</p>\n<p><strong><em>입력</em></strong></p>\n<p>첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1≤V≤20,000, 1≤E≤300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1≤K≤V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.</p>\n<p><strong><em>출력</em></strong></p>\n<p>첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.</p>\n</blockquote>\n<h3>문제 풀이</h3>\n<ol>\n<li>edges를 돌면서 1차원 배열에 연결 간선을 넣어줌.(단방향)</li>\n<li>heap에 시작 정점을 넣는다.</li>\n<li>heap 사이즈가 0이 될 때까지 while\n<ol>\n<li>인접한 간선이 없으면 continue</li>\n<li>값이 갱신되지 않으면 continue</li>\n<li>인접한 간선들을 돌면서, 거리를 갱신.</li>\n<li>거리를 갱신하면 heap에 add</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"language-js\">var fs = require(\"fs\");\n// var input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\nvar input = fs.readFileSync(\"../../stdin\").toString().trim().split(\"\\n\");\nconst [vertexs, edgesLen] = input[0].split(\" \").map(e => +e);\nconst start = +input[1];\nconst edges = input.slice(2).map(e => e.split(\" \").map(el => +el));\n\nclass Heap {\n  constructor() {\n    this.arr = [0];\n  }\n\n  add(value) {\n    this.arr.push(value);\n    this._heapify();\n  }\n\n  pop() {\n    if (this.size() === 0) return -1;\n    const temp = this.arr.pop();\n    const returnValue = this.arr[1];\n    if (this.size() === 0) return temp;\n    this.arr[1] = temp;\n    this._heapify2();\n    return returnValue;\n  }\n\n  size() {\n    return this.arr.length - 1;\n  }\n\n  _heapify() {\n    const heap = this.arr;\n    let child = heap.length - 1;\n    let parent = Math.floor(child / 2);\n    while (parent !== 0) {\n      if (heap[parent][1] &#x3C;= heap[child][1]) break;\n      const temp = heap[parent];\n      heap[parent] = heap[child];\n      heap[child] = temp;\n      child = parent;\n      parent = Math.floor(child / 2);\n    }\n  }\n  _heapify2() {\n    const heap = this.arr;\n    let parent = 1;\n    let left = parent * 2;\n    let right = parent * 2 + 1;\n\n    while (heap[left] !== undefined || heap[right] !== undefined) {\n      if (heap[right] === undefined) {\n        if (heap[left][1] > heap[parent][1]) break;\n        this._change(left, parent, heap);\n        break;\n      }\n      if (heap[left][1] &#x3C;= heap[right][1]) {\n        if (heap[left][1] > heap[parent][1]) break;\n        [parent, left, right] = this._change(left, parent, heap);\n      } else {\n        if (heap[right][1] > heap[parent]) break;\n        [parent, left, right] = this._change(right, parent, heap);\n      }\n    }\n  }\n\n  _change(child, parent, heap) {\n    const temp = heap[parent];\n    heap[parent] = heap[child];\n    heap[child] = temp;\n    parent = child;\n    const left = parent * 2;\n    const right = parent * 2 + 1;\n    return [parent, left, right];\n  }\n}\n\nconst setArray = (n, fillValue) => Array(n + 1).fill(fillValue);\n\nconst dijkstraHeap = (vertexs, edges, start) => {\n  const adj = Array(vertexs + 1);\n  edges.forEach(edge => {\n    if (!adj[edge[0]]) adj[edge[0]] = [];\n    adj[edge[0]].push([edge[1], edge[2]]);\n  });\n  const distance = setArray(vertexs, Infinity);\n\n  const heap = new Heap();\n  let startVertex = [start, 0];\n  heap.add(startVertex);\n  distance[start] = 0;\n\n  while (heap.size()) {\n    const [index, value] = heap.pop();\n    if (!adj[index]) continue;\n    if (distance[index] &#x3C; value) continue;\n    adj[index].forEach(edge => {\n      const [vertex, value] = edge;\n      if (distance[vertex] &#x3C;= distance[index] + value) return;\n      distance[vertex] = distance[index] + value;\n      heap.add([vertex, distance[vertex]]);\n    });\n  }\n  return distance;\n};\n\nconst result = dijkstraHeap(vertexs, edges, start);\nresult.forEach((e, id) => {\n  if (id === 0) return;\n  e === Infinity ? console.log(\"INF\") : console.log(e);\n});\n</code></pre>","frontmatter":{"title":"[백준] 1753번 최단경로","date":"2020년 08월 10일, 00:30"}}},"pageContext":{"slug":"/10/post93/","previous":{"fields":{"slug":"/10/post92/"},"frontmatter":{"title":"다익스트라 알고리즘","path":"/posts/92"}},"next":{"fields":{"slug":"/10/post94/"},"frontmatter":{"title":"[백준] 11724번 연결요소개수","path":"/posts/94"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}