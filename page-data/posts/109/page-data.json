{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/109/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>기능개발</p>\n<p>문제 설명</p>\n<p>프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.</p>\n<p>또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 > 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.</p>\n<p>먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.</p>\n<p><strong><em>제한 사항</em></strong></p>\n<ul>\n<li>작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.</li>\n<li>작업 진도는 100 미만의 자연수입니다.</li>\n<li>작업 속도는 100 이하의 자연수입니다.</li>\n<li>배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.</li>\n</ul>\n<p><strong><em>입출력 예</em></strong></p>\n<table>\n<thead>\n<tr>\n<th>progresses</th>\n<th>speeds</th>\n<th>return</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[93, 30, 55]</td>\n<td>[1, 30, 5]</td>\n<td>[2, 1]</td>\n</tr>\n<tr>\n<td>[95, 90, 99, 99, 80, 99]</td>\n<td>[1, 1, 1, 1, 1, 1]</td>\n<td>[1, 3, 2]</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h3>문제 풀이</h3>\n<p>progress와 speed가 인덱스가 동일하니까 while문을 돌면서 증가시켜준다.\n앞에 기능이 미완료라면 뒤의 기능은 배포하지 못하니까 따로 함수로 count를 세줌.</p>\n<ol>\n<li>speeds 배열을 돌면서 progresses의 원소들을 증가시켜줌.</li>\n<li>배포가 가능한 애들을 확인.\n<ol>\n<li>getCompletedProgressCount 함수\n<ol>\n<li>100보다 크거나 같은 애들의 count를 세줌.</li>\n<li>그렇지 않으면, break</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>count만큼 progresses,speeds를 잘라줌.</li>\n<li>count가 0이 아니라면 answer에 넣음.</li>\n</ol>\n<h3>소스코드</h3>\n<pre><code class=\"language-js\">function solution(progresses, speeds) {\n  const answer = [];\n  while (progresses.length) {\n    speeds.forEach((speed, index) => {\n      progresses[index] += speed;\n    });\n    const completedProgressCount = getCompletedProgressCount(progresses);\n    progresses = progresses.slice(completedProgressCount, progresses.length);\n    speeds = speeds.slice(completedProgressCount, speeds.length);\n    if (completedProgressCount > 0) answer.push(completedProgressCount);\n  }\n  return answer;\n}\n\nfunction getCompletedProgressCount(progresses) {\n  let count = 0;\n  for (let i = 0; i &#x3C; progresses.length; i++) {\n    if (progresses[i] >= 100) count++;\n    else break;\n  }\n  return count;\n}\n</code></pre>","frontmatter":{"title":"[프로그래머스] 레벨2 (level2) 기능개발","date":"2020년 12월 24일, 15:30"}}},"pageContext":{"slug":"/11/post109/","previous":{"fields":{"slug":"/11/post108/"},"frontmatter":{"title":"[프로그래머스] 레벨2 (level2) 타겟 넘버","path":"/posts/108"}},"next":{"fields":{"slug":"/12/post110/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 순위","path":"/posts/110"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}