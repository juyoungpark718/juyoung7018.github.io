{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/125/","result":{"data":{"markdownRemark":{"html":"<h2>카드 짝 맞추기</h2>\n<ul>\n<li>링크(<a href=\"https://programmers.co.kr/learn/courses/30/lessons/72415\">https://programmers.co.kr/learn/courses/30/lessons/72415</a>)</li>\n</ul>\n<h2>1차 시도(실패)</h2>\n<h3>문제 접근</h3>\n<ol>\n<li>카드를 순서를 정해서 지워야하니까 순열을 통해 경우의 수를 구한다.</li>\n<li>카드의 순서를 구하고 해당 순서로 최소 이동 횟수를 찾는다.</li>\n<li>(r,c) 시작지점으로부터 순서에 맞게 가장 가까운 카드를 찾는다.</li>\n<li>찾은 카드는 지워주고, 카드가 지워지면 다시 시작 포인트로 잡고 순서에 맞는 가장 가까운 카드를 찾는 것을 반복한다.</li>\n</ol>\n<h3>문제점</h3>\n<ul>\n<li>카드가 두 장이 존재하는데, 시작지점에서부터 가장 가까운 거리에 있는 카드를 선택해도 최단거리가 아닐 수 있음.</li>\n<li>이 문제점 때문에 테스트 케이스 11번이 계속 틀림.</li>\n</ul>\n<h2>2차 시도(성공)</h2>\n<h3>문제풀이</h3>\n<ol>\n<li>카드 순서 경우의 수를 구해준다.</li>\n<li>시작 위치에서 2가지 경우의 카드로 가는 길로 간다.</li>\n<li>해당 카드에서 같은 카드로 가서 카드를 지운다.</li>\n<li>카드가 지워진 시점에서 다시 재귀적으로 함수를 실행시킨다.(2-4 반복)</li>\n</ol>\n<h3>소스코드</h3>\n<pre><code class=\"language-js\">const log = console.log;\n// 라이언 1 프로도 2 어피치 3 \n\nconst permutation = (arr, str, length) => {\n    return arr.reduce((acc, val, i) => {\n        const newArr = [...arr];\n        newArr.splice(i, 1);\n        const result = permutation(newArr, str + String(val), length);\n        if((str+val).length === length){\n            acc.push(str+val);\n        }\n        acc.push(...result);\n        return acc;\n    }, [])\n}\n\nfunction solution(board, r, c) {\n    const cards = getCards(board);\n    const cardLen = cards.length;\n    let res = [Infinity];\n    const ps = permutation(cards, \"\", cardLen);\n    \n    for(const p of ps){\n        const order = [...p].map(e => +e);\n        const newBoard = board.map(e => [...e]);\n        getAnswer(newBoard, r, c, order, 0, res);    \n    }\n    \n    return res[0] + cardLen*2;\n}\n\nfunction getAnswer(board, r, c, order, total, res){\n    if(order.length === 0){\n        res[0] = Math.min(res[0], total);\n        return;\n    };\n    const card = order.shift();\n    const firsts = findCard(board, r, c, card);\n    \n    firsts.forEach(e => {\n        const [row, col, count] = e;\n        board[row][col] = 0;\n        const [row2, col2, count2] = findCard(board, row, col, card)[0];\n        board[row2][col2] = 0;\n        getAnswer(board, row2, col2, [...order], total+count+count2, res);\n        board[row][col] = card;\n        board[row2][col2] = card;\n    });\n}\n\nfunction findCard(board, r, c, card){\n    const n = board.length;\n    let result = [];\n    const visited = Array.from(Array(n), () => Array(n).fill(0));\n    const coords = [[r, c, 0]];\n    \n    while(coords.length){\n        const [row, col, count] = coords.shift();\n        if(board[row][col] === card){\n            result.push([row, col, count]);\n        };\n        visited[row][col] = 1;\n        const temp = getCoords(board, row, col, count, visited);\n        temp.forEach(([row, col]) => visited[row][col] = 1); \n        coords.push(...temp);\n    }\n    return result;\n}\n\nfunction getCoords(board, r, c, count, visited){\n    const n = board.length;\n    const coords = [];\n    const dr = [1,-1,0,0];\n    const dc = [0,0,1,-1];\n    \n    for(let i=0 ; i&#x3C;4 ; i++){\n        const row = r+dr[i];\n        const col = c+dc[i];\n        \n        if(col &#x3C; 0 || row &#x3C; 0 || col >= n || row >= n \n           ||  visited[row][col] === 1) continue;\n        coords.push([row, col, count+1]);\n    }\n    \n    const cntl = [\n        cntlUp(board,r,c),\n        cntlDown(board,r,c),\n        cntlLeft(board,r,c),\n        cntlRight(board,r,c)\n    ];\n    cntl.forEach((p) => {\n        const [row, col, d] = p;\n        if(visited[row][col] === 1 || dupCheck(coords, [row, col])) return;\n        coords.push([row, col, d+count]);\n    });\n    \n    return coords;\n}\n\nfunction dupCheck(arrs, point){\n    return arrs.some((e) => e[0] === point[0] &#x26;&#x26; e[1] === point[1]);\n}\n\nfunction cntlUp(board, r, c){\n    if(r === 0) return [0, c, 0];\n    for(let i=r-1 ; i>0 ; i--){\n        if(board[i][c] !== 0) return [i, c, 1];\n    }\n    return [0, c, 1];\n}\n\nfunction cntlDown(board, r, c){ \n    const n = board.length;\n    if(r === n-1) return [n-1, c, 0]\n    for(let i=r+1 ; i&#x3C;n ; i++){\n        if(board[i][c] !== 0) return [i, c, 1];\n    }\n    return [n-1, c, 1];\n}\n\nfunction cntlLeft(board, r, c){ \n    if(c === 0) return [r, 0, 0]\n    for(let i=c-1 ; i>0 ; i--){\n        if(board[r][i] !== 0) return [r, i, 1];\n    }\n    return [r, 0, 1];\n}\n\nfunction cntlRight(board, r, c){\n    const n = board.length;\n    if(c === n-1) return [r, n-1, 0];\n    for(let i=c+1 ; i&#x3C;n ; i++){\n        if(board[r][i] !== 0) return [r, i, 1];\n    }\n    return [r, n-1, 1];\n}\n\nfunction getCards(board){\n    const n = board.length;\n    const set = new Set();\n    for(let r=0 ; r&#x3C;n; r++){\n        for(let c=0 ; c&#x3C;n ; c++){\n            if(board[r][c] !== 0) set.add(board[r][c]);\n        }\n    }\n    return [...set];\n}\n</code></pre>","frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 카드 짝 맞추기","date":"2021년 03월 16일, 20:00"}}},"pageContext":{"slug":"/13/post125/","previous":{"fields":{"slug":"/13/post124/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 메뉴 리뉴얼","path":"/posts/124"}},"next":{"fields":{"slug":"/13/post126/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 스타수열","path":"/posts/126"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}