{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/37/","result":{"data":{"markdownRemark":{"html":"<h1>첫번째 풀이(2020-06-08)</h1>\n<h2>디스크 컨트롤러</h2>\n<h3>문제설명</h3>\n<blockquote>\n<p>하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.</p>\n<p>예를들어,</p>\n<pre><code>- 0ms 시점에 3ms가 소요되는 A작업 요청\n- 1ms 시점에 9ms가 소요되는 B작업 요청\n- 2ms 시점에 6ms가 소요되는 C작업 요청\n</code></pre>\n<p>와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; height: 175.4601226993865px\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a5046d784e0e694709877d5590584aad/062c8/disk1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.993865030674847%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA30lEQVQY042Mu0oDQRRA9zv1AyzsxOAfiIrEH4hiGRtbC4mJTSLY2KVR0BBkHtmJzsxudrOZOTKx0cLghQOHey8nCxECUD15FreCephTj2ZUPUk9NMR0BGKMRH74H2SkN3cPN2fUF4cU3TbldYfi8oSye0rzdkUw/Y2RX8EXFxk8thk87CKf92HaIrwfEaYHhMkeq/EO4fWY/052Pq7YuoPtPvQmEJfw6cGV3/gK3AKccxux1uK9J1sWFgrDyircXGPMDJNrPub5muRaCZRSaK0RQiClXJM87ZKnWNM0fAEWGXcFvIIVSgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"disk1\"\n        title=\"disk1\"\n        src=\"/static/a5046d784e0e694709877d5590584aad/a6d36/disk1.png\"\n        srcset=\"/static/a5046d784e0e694709877d5590584aad/222b7/disk1.png 163w,\n/static/a5046d784e0e694709877d5590584aad/ff46a/disk1.png 325w,\n/static/a5046d784e0e694709877d5590584aad/a6d36/disk1.png 650w,\n/static/a5046d784e0e694709877d5590584aad/e548f/disk1.png 975w,\n/static/a5046d784e0e694709877d5590584aad/3c492/disk1.png 1300w,\n/static/a5046d784e0e694709877d5590584aad/062c8/disk1.png 1386w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; height: 227.30061349693253px\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1343df51c3faefc17d9aab0604e61f2a/2eb79/disk2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.96932515337423%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABUUlEQVQoz6WQvU4bQRSF99FSQxshniBvQJ8uFXI6pLxCqnQpohAkkJCsEEhsizheghUswMY7w3pmdsbz80Wz66Sg5UifztFczZHuLVJK/MM5iw8QIvhMAK0tSju0spiYkIdjxOuPPPaOqA9OkG8+Ue1/JkhDVkFKxAQhgTIWbyuiWxDtAt/MmZbfKS/7/B5/5Xp0yux6jKk168ayNh3NShNC6ApTax6CbpP+scf8ywsejrcQpy+pz15hznZw57vY/jZ29p5OiafKWxY5HN3D22Hg3QQGf+6Y/hpQlpfcTifclD+RYk70Bu8UttHdieITNmcrCGs+jB7ofVP0+hVXy4bnqKiEYDK8YDYeMBudMxkNmS8WPEqJlAIhBFJsXAqqqmpzJmcp5WYmWa1W3crOe4x1KNPQWIfRuh0qpajruiV/yL5cLv8X5pzfc7ExhhgjfwFs8BA8dQuFKgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"disk2\"\n        title=\"disk2\"\n        src=\"/static/1343df51c3faefc17d9aab0604e61f2a/a6d36/disk2.png\"\n        srcset=\"/static/1343df51c3faefc17d9aab0604e61f2a/222b7/disk2.png 163w,\n/static/1343df51c3faefc17d9aab0604e61f2a/ff46a/disk2.png 325w,\n/static/1343df51c3faefc17d9aab0604e61f2a/a6d36/disk2.png 650w,\n/static/1343df51c3faefc17d9aab0604e61f2a/e548f/disk2.png 975w,\n/static/1343df51c3faefc17d9aab0604e61f2a/2eb79/disk2.png 1256w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)\n- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)\n- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)\n</code></pre>\n<p>이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다.</p>\n<p>하지만 A → C → B 순서대로 처리하면</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; height: 223.31288343558282px\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1ece6df22e5fccc59d7801d1a5e8b0a3/37048/disk3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.355828220858896%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABWklEQVQoz4WQO2sbQRSF938GXLtJEdT4L7gLpHIRu7ONlSII0hqCkR/EsvFLiqVIRJaMd1crCWVmdmZ2tfOZGWSIKh849wzcyzn3TuScw1WOEkfZTtC7vzCHN5hGG71/jfh6ThHPAT9X4txyxfI/Vnh4r8gXj9xoRrc97o6Oefh+wp8fZ/QaTZKfbazkXbz5RKFWZdigrArk0qCWFl3ZsHUYHn+m/P2R8rGGfdzC9rexnRqm/Qlzv4l9PliZVkT5Enqp4O9MkwlDYQyFLVBSMugP6HW79Ft7PLW+ML7ZQQ7rqHEDNfqGeqqjhvuIl9MQHQybiePDCWw0oT5aP0FKiRCC3IJW/lvePz3qdDqcnl/Qumxxd3VNHMcopYJZnudorclz/1ZBpfy3RiEWKClYLBZYa4nm8zlZlpFNUtI4ZjqdBs5mM3zP62QyIU3TQB/4pp6+lyRJCC+KglfKIQ3dNLpDLgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"disk3\"\n        title=\"disk3\"\n        src=\"/static/1ece6df22e5fccc59d7801d1a5e8b0a3/a6d36/disk3.png\"\n        srcset=\"/static/1ece6df22e5fccc59d7801d1a5e8b0a3/222b7/disk3.png 163w,\n/static/1ece6df22e5fccc59d7801d1a5e8b0a3/ff46a/disk3.png 325w,\n/static/1ece6df22e5fccc59d7801d1a5e8b0a3/a6d36/disk3.png 650w,\n/static/1ece6df22e5fccc59d7801d1a5e8b0a3/e548f/disk3.png 975w,\n/static/1ece6df22e5fccc59d7801d1a5e8b0a3/3c492/disk3.png 1300w,\n/static/1ece6df22e5fccc59d7801d1a5e8b0a3/37048/disk3.png 1352w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<pre><code>- A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)\n- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)\n- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)\n이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다.\n</code></pre>\n<p>각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다)</p>\n<p><strong><em>제한 사항</em></strong></p>\n<ul>\n<li>jobs의 길이는 1 이상 500 이하입니다.</li>\n<li>jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.</li>\n<li>각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.</li>\n<li>각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.</li>\n<li>하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.</li>\n</ul>\n<p><strong><em>입출력 예</em></strong></p>\n<table>\n<thead>\n<tr>\n<th>jobs</th>\n<th>return</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[[0, 3], [1, 9], [2, 6]]</td>\n<td>9</td>\n</tr>\n</tbody>\n</table>\n<p><strong><em>입출력 예 설명</em></strong></p>\n<p>문제에 주어진 예와 같습니다.</p>\n<ul>\n<li>0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다.</li>\n<li>1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다.</li>\n<li>2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다.</li>\n</ul>\n</blockquote>\n<h2>문제풀이</h2>\n<p>현재 <strong>excuteTime</strong>보다 요청시간이 작은 것들 중에서 수행시간이 가장 짧은 것부터 계산해주면 된다.</p>\n<ol>\n<li>처음 시작 job을 구하기 위해서 요청시간으로 정렬하고, 같은 경우에는 수행시간으로 정렬한다.(<strong>오름차순</strong>)</li>\n<li>처음 시작 job을 shift해서 뽑고, 나머지 jobs에 대해서 while문을 실행한다.\n<ol>\n<li>처음 job으로 answer, time을 계산해준다.</li>\n</ol>\n</li>\n<li>jobs중에서 <strong>excuteTime</strong>보다 요청 시간이 작은 jobs들 중에 수행 시간이 짧은 것을 선택.\n<ol>\n<li>여기서 만약 <strong>excuteTime</strong>보다 작은 job이 없다면, 요청시간으로 정렬된 job에서 제일 첫 번째를 선택.</li>\n</ol>\n</li>\n<li>job을 jobs에서 제거해준다.</li>\n<li>job의 요청시간이 <strong>excuteTime</strong>보다 클 때에는 맨 처음 뽑았던 job과 동일하게 처리(while문 전에 뽑은 job).</li>\n<li>job의 요청시간이 <strong>excuteTime</strong>보다 작을 때에는,\n<ol>\n<li><strong>excuteTime</strong> - 요청시간을 뺀 값과 수행 시간을 더한 것이 요청시간 부터 수행시간까지의 시간. answer에 더해준다.(<strong>answer += excuteTime - job.req + job.end</strong>)</li>\n<li><strong>excuteTime</strong> += 수행시간**으로 **excuteTime**을 업데이트 시켜준다.</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"language-js\">function solution(jobs) {\n  let len = jobs.length;\n  jobs = re(jobs);\n  jobs.sort((a, b) => {\n    if (a.req > b.req) {\n      return 1;\n    } else if (a.req &#x3C; b.req) {\n      return -1;\n    } else {\n      return a.end - b.end;\n    }\n  });\n  let first = jobs.shift();\n  let excuteTime = first.req + first.end;\n  let answer = first.end;\n\n  while (jobs.length !== 0) {\n    let nextJob = 0;\n    for (let i = 1; i &#x3C; jobs.length; i++) {\n      if (jobs[i].req > excuteTime) break;\n      else {\n        if (jobs[i].end &#x3C; jobs[nextJob].end) {\n          nextJob = i;\n        }\n      }\n    }\n    let job = jobs.splice(nextJob, 1)[0];\n    if (job.req > excuteTime) {\n      answer += job.end;\n      excuteTime = job.end + job.req;\n    } else {\n      answer += excuteTime - job.req + job.end;\n      excuteTime = excuteTime + job.end;\n    }\n  }\n\n  return Math.floor(answer / len);\n}\n\nfunction re(jobs) {\n  return jobs.map((e, id) => {\n    return { id, req: e[0], end: e[1] };\n  });\n}\n</code></pre>\n<h3>아쉬운 점 || 느낀 점</h3>\n<p>와 진짜 너무 어렵다. 이전에 자물쇠와 키 문제도 도전했는데 풀지 못했다.(<del>심지어 구글링도함</del>)<br>\n디스크 컨트롤러는 저번에 풀다가 못풀고, 이번에 다시 도전해서 풀었는데, 이것도 질문하기 + 구글링의 힘으로 풀었다.<br>\n레벨 3으로 오면서 하루에 1문제가 너무 어려워지고 있다.<br>\n몇 시간을 투자해서 푸는데, 코딩테스트에는 시간 제한이 있는걸 생각하면 아직 초보자 수준인 것 같다.<br>\n갈 길이 너무 멀다..</p>\n<h1>두번째 풀이</h1>\n<h3>문제 풀이</h3>\n<p>예외처리가 필요한 부분</p>\n<ul>\n<li>디스크가 아무 일도 하지 않는 경우는 현재 시간을 job의 요청시간 + job의 실행시간</li>\n</ul>\n<ol>\n<li>jobs를 index가 포함된 Object의 배열로 바꿔줌.</li>\n<li>jobs를 시작 시간으로 정렬</li>\n<li>while문을 돌면서 jobs을 제거해줌\n<ol>\n<li>현재 시간에 실행 가능한 job들이 있는 경우\n<ol>\n<li>time을 기준으로 정렬 후 해당 job을 제거해준다</li>\n</ol>\n</li>\n<li>현재 시간이 실행 가능한 job이 없는 경우\n<ol>\n<li>시작 시간 순으로 정렬된 jobs에서 뽑고 현재 시간을 갱신해준다.</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3>소스 코드</h3>\n<pre><code class=\"language-js\">function solution(jobs) {\n  let answer = 0;\n  let currentTime = 0;\n  const len = jobs.length;\n  jobs = jobs\n    .map((job, idx) => ({ idx, start: job[0], time: job[1] }))\n    .sort((a, b) =>\n      b.start === a.start ? b.time - a.time : b.start - a.start\n    );\n  while (jobs.length) {\n    const canExcute = jobs.filter(job => job.start &#x3C;= currentTime);\n    if (!canExcute.length) {\n      const job = jobs.pop();\n      currentTime = job.start + job.time;\n      answer += job.time;\n      continue;\n    }\n    canExcute.sort((a, b) => b.time - a.time);\n    const pickedJob = canExcute.pop();\n    jobs = jobs.filter(job => job.idx !== pickedJob.idx);\n    answer += currentTime - pickedJob.start + pickedJob.time;\n    currentTime += pickedJob.time;\n  }\n  return Math.floor(answer / len);\n}\n</code></pre>\n<h3>아쉬운 점 || 느낀 점</h3>\n<p>스터디 때 풀이를 보지 못했다면, 예외처리에 시간이 오래 걸렸을 것 같음.</p>","frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 디스크컨트롤러","date":"2020년 12월 27일, 22:22"}}},"pageContext":{"slug":"/4/post37/","previous":{"fields":{"slug":"/12/post110/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 순위","path":"/posts/110"}},"next":{"fields":{"slug":"/1/post7/"},"frontmatter":{"title":"[우아한 테크캠프] - 3기 지원 후기(1,2차)","path":"/posts/7"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}