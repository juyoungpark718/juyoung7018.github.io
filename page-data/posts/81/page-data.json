{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/81/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>단지 번호 붙이기</h2>\n<h3>문제 설명</h3>\n<p>&#x3C;그림 1>과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다.<br>\n철수는 이 지도를 가지고 연결된 집들의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다.<br>\n여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다.<br>\n&#x3C;그림 2>는 &#x3C;그림 1>을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 409px; height: 193.2085889570552px\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d5d82904c2c866f2cb4c08699170c370/7a75e/apt-complex1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.239263803680984%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAABhElEQVQoz2XRXY+qMBAGYP7/rzHxTuNGcZd1jTmi0BZaKP2mUBCNkXNj2BO3yd6cuZzMM8m8E9zvd621c67ve2NM0zRd1xlj+r7//qmu6wghAICKMauUwbhtGlPX4zgGzrkkSTjnxpg0TYui4JzneS6l9Jgxtl6vZ7NZtNvh0wkuFqwswX5/cS64XC4YYyll0zRZllFKhRBVVVlrPQYALJaL+Xy+2+8pQsV2K4Qgm83V2hcmhFRVpbX22BhDKa3r2uM4jsNN+BlFpyQhSZKvVhKk+O1tsDboug5CWBQFYwwhRAhRSpVlqbX2WHBxhueMZJwLnIIs+pR/jujjY3DuhRFCQgilFMbYY3+Ix5zx6BR9gS9McQzjI4pRlcM8u15vr8DSNPWBFUVBCNFa53nOOfe4otX78X0Vr0IQLg/L7TE8ZIckPQ/DENxuN8bY74eEEMYYKWXbth5ba2EJE5pAASGFSqi2aQUXj8cj8BPTNPkt4zg+n8/v/2qaJmusNXb8O/42/wG4Dd4vobR84wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"apt-complex1\"\n        title=\"apt-complex1\"\n        src=\"/static/d5d82904c2c866f2cb4c08699170c370/7a75e/apt-complex1.png\"\n        srcset=\"/static/d5d82904c2c866f2cb4c08699170c370/222b7/apt-complex1.png 163w,\n/static/d5d82904c2c866f2cb4c08699170c370/ff46a/apt-complex1.png 325w,\n/static/d5d82904c2c866f2cb4c08699170c370/7a75e/apt-complex1.png 409w\"\n        sizes=\"(max-width: 409px) 100vw, 409px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong><em>입력</em></strong></p>\n<p>첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 <strong>5≤N≤25</strong>)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.</p>\n<p><strong><em>출력</em></strong></p>\n<p>첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 <strong>오름차순</strong>으로 정렬하여 한 줄에 하나씩 출력하시오.</p>\n</blockquote>\n<h3>문제 풀이</h3>\n<ol>\n<li>apt를 표현한 2차원 배열과, 그 배열에서 1인 곳(아파트가 있는 곳)의 좌표를 뽑은 배열, visited배열을 작성해준다.(각각 aptArr,apts,visitedArr)</li>\n<li>excuteBFS\n<ol>\n<li>시작은 apts배열의 처음 원소부터 시작한다.</li>\n<li>apts의 크기만큼 for문을 돌림.\n<ol>\n<li>queue의 길이가 0이면, 연결된 좌표가 없다는 것이므로, 세어준 apt를 complex 배열에 넣어준다.</li>\n<li>길이가 0이 아니라면, queue에서 뽑아서 계속 진행한다.(이때, apt++)</li>\n<li>현재 아파트에서 상하좌우를 모두 확인해주고, queue에 넣어준다.</li>\n</ol>\n</li>\n<li>마지막 apt는 들어가지 않기 때문에 complex에 넣어준다.</li>\n<li>complex를 리턴.</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"language-js\">const fs = require(\"fs\");\n\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n// const input = fs.readFileSync(\"./stdin\").toString().trim().split(\"\\n\");\n\nconst dx = [1, 0, -1, 0];\nconst dy = [0, 1, 0, -1];\n\nconst aptsLength = Number(input[0]);\n\nconst getApts = inputs => {\n  const arr = [];\n  inputs.forEach((rowInput, rowIndex) => {\n    rowInput\n      .trim()\n      .split(\"\")\n      .forEach((element, elementIndex) =>\n        Number(element) === 1 ? arr.push([elementIndex, rowIndex]) : null\n      );\n  });\n  return arr;\n};\n\nconst getAptArr = inputs => {\n  const arr = [];\n  inputs.forEach(rowInput => {\n    const row = rowInput\n      .trim()\n      .split(\"\")\n      .map(element => Number(element));\n    arr.push(row);\n  });\n  return arr;\n};\n\nconst aptArr = getAptArr(input.slice(1, input.length));\nconst apts = getApts(input.slice(1, input.length));\nconst visitedArr = Array.from(Array(aptsLength), () =>\n  Array(aptsLength).fill(false)\n);\n\nconst excuteBFS = () => {\n  const complex = [];\n  const queue = [apts[0]];\n  let apt = 0;\n  for (let aptIndex = 1; aptIndex &#x3C; apts.length; ) {\n    let [startX, startY] = [-1, -1];\n    if (queue.length === 0) {\n      [startX, startY] = apts[aptIndex];\n      aptIndex++;\n      if (visitedArr[startY][startX]) continue;\n      complex.push(apt);\n      apt = 1;\n    } else {\n      [startX, startY] = queue.shift();\n      apt++;\n    }\n    visitedArr[startY][startX] = true;\n\n    //상하좌우\n    for (let i = 0; i &#x3C; 4; i++) {\n      const nx = startX + dx[i];\n      const ny = startY + dy[i];\n\n      if (nx &#x3C; 0 || ny &#x3C; 0 || nx >= aptsLength || ny >= aptsLength) continue;\n      if (visitedArr[ny][nx] || aptArr[ny][nx] === 0) continue;\n      visitedArr[ny][nx] = true;\n      queue.push([nx, ny]);\n    }\n  }\n  complex.push(apt);\n  return complex;\n};\n\nconst complex = excuteBFS();\nconsole.log(complex.length);\ncomplex.sort((a, b) => a - b);\ncomplex.forEach(element => console.log(element));\n</code></pre>","frontmatter":{"title":"[백준] 2667번 단지번호붙이기","date":"2020년 07월 20일, 09:50"}}},"pageContext":{"slug":"/9/post81/","previous":{"fields":{"slug":"/8/post80/"},"frontmatter":{"title":"[백준] 2606번 바이러스","path":"/posts/80"}},"next":{"fields":{"slug":"/9/post82/"},"frontmatter":{"title":"[백준] 2644번 촌수계산","path":"/posts/82"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}