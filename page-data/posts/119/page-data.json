{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/119/","result":{"data":{"markdownRemark":{"html":"<h2>B - tree</h2>\n<ul>\n<li>\n<p>이진 트리를 확장해서 노드가 가질 수 있는 값이 2 이상이고, 가질 수 있는 자식의 노드 숫자도 2이상인 트리 구조.</p>\n</li>\n<li>\n<p>B-트리의 기본 개념은 내부 노드의 자식 노드의 수가 미리 정해진 범위 내에서 변경가능.</p>\n</li>\n<li>\n<p>항목이 삽입되거나 삭제될 때, 내부 노드는 해당 범위의 자식 노드의 수를 만족시키기 위해 분리되거나 혹은 다른 노드와 합쳐지게 된다.</p>\n</li>\n<li>\n<p>자식 노드의 수가 일정 범위 내에서만 유지되면 되므로 분리 및 합침을 통한 재균형 과정은 다른 <a href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EA%B0%80_%EA%B7%A0%ED%98%95_%EC%9D%B4%EC%A7%84_%ED%83%90%EC%83%89_%ED%8A%B8%EB%A6%AC\">자가 균형 이진 탐색 트리</a>만큼 자주 일어나지 않지만, 저장 공간에서의 손실은 있게 된다.</p>\n</li>\n<li>\n<p>삽입 및 삭제를 대수시간(log n)으로 할 수 있다.</p>\n</li>\n<li>\n<p><strong>조건</strong></p>\n<ol>\n<li>노드의 자료의 값들은 정렬되어야 한다.</li>\n<li>노드의 자료수가 K면, 자식의 수는 K + 1 이여야 함.</li>\n<li>한 노드 자료보다 왼쪽 서브트리는 노드보다 작은 키값, 오른쪽은 큰값.</li>\n<li>루트 노드를 제외한 모든 노드는 적어도 M/2(소수점 내림)의 키를 가지고 있어야 한다. (M은 차수)</li>\n<li>리프 노드는 같은 레벨</li>\n</ol>\n</li>\n<li>\n<p>B tree의 B는 무엇인가?</p>\n<ul>\n<li>B-트리의 창시자인 <a href=\"https://ko.wikipedia.org/wiki/%EB%A3%A8%EB%8F%8C%ED%94%84_%EB%B0%94%EC%9D%B4%EC%96%B4\">루돌프 바이어</a>는 'B'가 무엇을 의미하는지 따로 언급하지는 않았다. 가장 가능성 있는 대답은 리프 노드를 같은 높이에서 유지시켜주므로 균형잡혀있다(balanced)는 뜻에서의 'B'라는 것이다. '바이어(Bayer)'의 'B'를 나타낸다는 의견도, 혹은 그가 일했던 보잉 과학 연구소(Boeing Scientific Research Labs)에서의 'B'를 나타낸다는 의견도 있다.</li>\n<li><del>Balanced가 유력하지 않을까 생각한다.</del></li>\n</ul>\n</li>\n<li>\n<p>삽입 구현</p>\n<ul>\n<li>리프노드에 값을 추가해줘야하므로 리프노드를 찾아야한다.</li>\n<li>트리의 차수에 맞춰서 data를 가져야하고, 차수랑 같은 값을 가지는 경우 분할해줘야한다.\n<ul>\n<li>분할 해주는 과정에서 루트인 경우와 부모를 가지는 경우를 나눠서 분할한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">class B {\n  constructor(m, parent, datas, trees, leaf = true) {\n    this.m = m; // 트리의 차수\n    this.parent = parent ? parent : null;\n    this.datas = datas ? datas : [];\n    this.trees = trees ? trees : [];\n    this.leaf = leaf;\n  }\n\n  add(value) {\n    // 리프노드가 아닌 경우는 해당 값을 넣을 트리를 찾아야한다.\n    if (!this.leaf) {\n      const treeIndex = this.datas.findIndex((data) => value &#x3C;= data);\n      const dataIdx = treeIndex &#x3C; 0 ? this.datas.length : treeIndex;\n      this.trees[dataIdx].add(value);\n    } else {\n      this.datas.push(value);\n      this.datas.sort((a, b) => a - b);\n    }\n\n    // 트리가 가질 수 있는 데이터가 꽉찬 경우\n    if (this.datas.length === this.m) {\n      // root인 경우 - 루트인 경우에는 m/2의 값을 기준으로 트리를 새로 만들어주면 된다.\n      if (this.parent === null) {\n        const pivot = this.m % 2 === 0 ? this.m / 2 : parseInt(this.m / 2);\n        const { leftB_tree, rightB_tree } = this.split(pivot, this);\n        this.datas = [this.datas[pivot]];\n        this.trees = [leftB_tree, rightB_tree];\n        this.leaf = false;\n        return;\n      }\n\n      //root가 아닌 경우(부모가 있는 경우) - m/2 값을 부모의 데이터에 추가하고, 나눠진 tree는 부모의 trees에 추가해줘야한다.\n      const pivot = this.m % 2 === 0 ? this.m / 2 - 1 : parseInt(this.m / 2);\n      const target = this.datas[pivot]; // 나눠지는 값\n      const parent = this.parent;\n      parent.datas.push(target);\n      parent.datas.sort((a, b) => a - b);\n      const idx = parent.datas.findIndex((data) => target === data);\n      const parentRestTrees = parent.datas.slice(idx + 1); // target이 추가되는 자리에 존재했던 tree들\n      const { leftB_tree, rightB_tree } = this.split(pivot, parent);\n      parent.trees[idx] = leftB_tree;\n      parent.trees[idx + 1] = rightB_tree;\n      parent.trees = parent.trees.concat(parentRestTrees);\n      parent.leaf = false;\n      return;\n    }\n    return;\n  }\n\n  split(pivot, parent) {\n    const leftDatas = this.datas.slice(0, pivot);\n    const rightDatas = this.datas.slice(pivot + 1);\n    const leftTrees = this.trees.slice(0, pivot + 1);\n    const rightTrees = this.trees.slice(pivot + 1);\n    const isLeaf = leftTrees.length > 0 ? false : true;\n    const leftB_tree = new B(this.m, parent, leftDatas, leftTrees, isLeaf);\n    const rightB_tree = new B(this.m, parent, rightDatas, rightTrees, isLeaf);\n    return { leftB_tree, rightB_tree };\n  }\n}\n</code></pre>\n<h3>참고</h3>\n<p><a href=\"https://hyungjoon6876.github.io/jlog/2018/07/20/btree.html\">https://hyungjoon6876.github.io/jlog/2018/07/20/btree.html</a></p>\n<p><a href=\"https://matice.tistory.com/8\">https://matice.tistory.com/8</a></p>\n<p><a href=\"https://ko.wikipedia.org/wiki/B_%ED%8A%B8%EB%A6%AC\">https://ko.wikipedia.org/wiki/B_%ED%8A%B8%EB%A6%AC</a></p>\n<p><a href=\"https://www.cs.usfca.edu/~galles/visualization/BTree.html(%EC%9E%91%EB%8F%99%EC%9D%84\">https://www.cs.usfca.edu/~galles/visualization/BTree.html(작동을</a> 잘 볼 수 있어서 구현하는데 있어서 많은 힌트를 얻음.)</p>","frontmatter":{"title":"[자료구조] B tree","date":"2021년 02월 21일, 12:41"}}},"pageContext":{"slug":"/12/post119/","previous":{"fields":{"slug":"/12/post118/"},"frontmatter":{"title":"[디자인패턴] 싱글턴(Singleton)","path":"/posts/118"}},"next":{"fields":{"slug":"/13/post120/"},"frontmatter":{"title":"[블로그 개발] Utterances 적용","path":"/posts/120"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}