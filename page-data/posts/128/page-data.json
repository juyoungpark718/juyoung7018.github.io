{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/128/","result":{"data":{"markdownRemark":{"html":"<h2>최소비용 구하기</h2>\n<ul>\n<li>링크(<a href=\"https://www.acmicpc.net/problem/1916\">https://www.acmicpc.net/problem/1916</a>)</li>\n</ul>\n<h3>문제풀이</h3>\n<ul>\n<li>힙으로 구현된 우선순위큐를 이용하여 다익스트라로 풀면 된다.</li>\n</ul>\n<ol>\n<li>인접행렬을 만들어준다.</li>\n<li>시작지점을 heap에 넣어주고, heap의 size가 0이 될 때까지 while문</li>\n<li>heap에서 시작지점, 비용을 꺼내고 현재 costs배열과 비용을 비교해서 다르면 넘어간다.(방문한 지점)</li>\n<li>인접행렬에서 시작지점에 대한 버스경로들을 구하고, costs배열과 비교해서 작으면 갱신하고 heap에 넣어준다.</li>\n<li>반복</li>\n</ol>\n<ul>\n<li>1 2 10, 1 2 20과 같은 중복 경우도 있는 것 같음.</li>\n</ul>\n<h3>소스코드</h3>\n<pre><code class=\"language-js\">const log = console.log;\nconst fs = require(\"fs\");\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n// const input = fs.readFileSync(\"./stdin\").toString().trim().split(\"\\n\");\nclass Heap {\n  constructor() {\n    this.arr = [0];\n  }\n\n  add(value) {\n    this.arr.push(value);\n    this._heapify();\n  }\n\n  pop() {\n    if (this.size() === 0) return -1;\n    const temp = this.arr.pop();\n    const returnValue = this.arr[1];\n    if (this.size() === 0) return temp;\n    this.arr[1] = temp;\n    this._heapify2();\n    return returnValue;\n  }\n\n  size() {\n    return this.arr.length - 1;\n  }\n\n  _heapify() {\n    const heap = this.arr;\n    let child = heap.length - 1;\n    let parent = Math.floor(child / 2);\n    while (parent !== 0) {\n      if (heap[parent][1] &#x3C;= heap[child][1]) break;\n      const temp = heap[parent];\n      heap[parent] = heap[child];\n      heap[child] = temp;\n      child = parent;\n      parent = Math.floor(child / 2);\n    }\n  }\n  _heapify2() {\n    const heap = this.arr;\n    let parent = 1;\n    let left = parent * 2;\n    let right = parent * 2 + 1;\n\n    while (heap[left] !== undefined || heap[right] !== undefined) {\n      if (heap[right] === undefined) {\n        if (heap[left][1] > heap[parent][1]) break;\n        this._change(left, parent, heap);\n        break;\n      }\n      if (heap[left][1] &#x3C;= heap[right][1]) {\n        if (heap[left][1] > heap[parent][1]) break;\n        [parent, left, right] = this._change(left, parent, heap);\n      } else {\n        if (heap[right][1] > heap[parent]) break;\n        [parent, left, right] = this._change(right, parent, heap);\n      }\n    }\n  }\n\n  _change(child, parent, heap) {\n    const temp = heap[parent];\n    heap[parent] = heap[child];\n    heap[child] = temp;\n    parent = child;\n    const left = parent * 2;\n    const right = parent * 2 + 1;\n    return [parent, left, right];\n  }\n}\n\nconst city = +input[0];\nconst bus = +input[1];\n\nif(city === 1){\n  console.log(0);\n  return;\n}\nif(bus === 1){\n  const [x, y, cost] = input[2].split(\" \").map((e) => +e);\n  console.log(cost);\n  return;\n}\nlet paths = [];\nfor (let i = 2; i &#x3C; bus + 2; i++) {\n  paths.push(input[i].split(\" \").map((e) => +e));\n}\n\nconst [startPoint, endPoint] = input[bus + 2].split(\" \").map((e) => +e);\n\nlet adj = Array.from(Array(city + 1), () => Array());\n\npaths.forEach(([start, end, cost]) => {\n  adj[start].push([end, cost]);\n});\n\n\nlet heap = new Heap();\nlet costs = Array(city+1).fill(Infinity);\ncosts[startPoint] = 0;\nheap.add([startPoint, 0]);\nwhile(heap.size()){\n  const [s, c] = heap.pop();\n  if(costs[s] !== c) continue;\n  for(let i=0 ; i&#x3C;adj[s].length ; i++){\n    const [end, cost] = adj[s][i];\n    if(costs[end] > cost + c){\n      costs[end] = cost + c;\n      heap.add([end, costs[end]]);\n    }\n  }\n}\n\nlog(costs[endPoint]);\n</code></pre>","frontmatter":{"title":"[백준] 1916번 최소비용 구하기","date":"2021년 03월 26일, 21:00"}}},"pageContext":{"slug":"/13/post128/","previous":{"fields":{"slug":"/13/post127/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 풍선터트리기","path":"/posts/127"}},"next":{"fields":{"slug":"/13/post129/"},"frontmatter":{"title":"[자바스크립트] 자바스크립트 스코프","path":"/posts/129"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}