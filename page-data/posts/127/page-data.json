{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/127/","result":{"data":{"markdownRemark":{"html":"<h2>풍선 터트리기</h2>\n<ul>\n<li>링크(<a href=\"https://programmers.co.kr/learn/courses/30/lessons/68646\">https://programmers.co.kr/learn/courses/30/lessons/68646</a>)</li>\n</ul>\n<h3>문제풀이</h3>\n<p>풍선이 남아 있을 수 있으려면, 왼쪽 풍선과 오른쪽 풍선을 확인해서, 작은 풍선을 1번만 터트리는 경우를 찾아야한다.<br>\n그래서, 두 가지 배열을 만들어야한다. 배열의 인덱스가 현재 풍선 위치라고 가정하고,</p>\n<ol>\n<li>왼쪽에서부터 현재 인덱스 전까지 남아있는 왼쪽 풍선은 무엇인지 저장하고 있는 배열을 만든다.</li>\n<li>오른쪽에서부터 현재 인덱스 전까지 남아있는 오른쪽 풍선은 무엇인지 저장하고 있는 배열을 만든다.</li>\n<li>그 다음 각 풍선을 돌면서, 왼쪽, 오른쪽의 풍선을 확인하여 현재 풍선이 터질 수 있는지 확인하면 된다.</li>\n</ol>\n<pre>\n  예제 : [-16,27,65,-2,58,-92,-71,-68,-61,-33]인 경우\n  현재 지점에서 왼쪽 풍선이 어떠한 풍선이 남는지 배열을 만든다면(새로운 배열의 1번째 원소는 -16으로 시작)\n  1. -16 vs 27 -> [-16,-16,0,0,0,0,0,0,0,0]\n  2. -16 vs 65 -> [-16,-16,-16,0,0,0,0,0,0,0]\n  ...\n  5. -16 vs -92 -> [-16,-16,-16,-16,-16,-92,0,0,0,0]\n  ...\n  9. -92 vs -33 -> [-16,-16,-16,-16,-16,-92,-92,-92,-92,-92]\n\n  위와 같은 배열이 만들어진다.\n  그리고 이와 동일하게 오른쪽에 대해서도 똑같이 배열을 만들면 된다.\n\n  left = [-16,-16,-16,-16,-16,-92,-92,-92,-92,-92]\n  right = [-92,-92,-92,-92,-92,-92,-71,-68,-61,-33]\n\n  이렇게 두개의 배열을 만들고,\n  [-16,27,65,-2,58,-92,-71,-68,-61,-33] 배열을 돌면서 확인해주면 된다.(첫번째, 마지막은 빼고 돌린다.)\n  i=1인 27의 경우 left[0] , right[2]를 확인\n  i=2인 65의 경우 left[1] , right[3]을 확인\n  ...\n</pre>\n<hr>\n<ul>\n<li>첫번째, 마지막 풍선은 항상 터질 수 있다.</li>\n</ul>\n<h3>소스코드</h3>\n<pre><code class=\"language-js\">const log = console.log;\nfunction solution(a) {\n\n    let answer = 0;\n    let len = a.length;\n    let left = Array(len).fill(0);\n    let right = Array(len).fill(0);\n    left[0] = a[0];\n    right[len-1] = a[len-1];\n    for(let i=1 ; i&#x3C;a.length ; i++){\n        if(a[i] > left[i-1]) left[i] = left[i-1];\n        else left[i] = a[i];\n    }\n    for(let i=len-2 ; i>=0 ; i--){\n        if(right[i+1] &#x3C; a[i]) right[i] = right[i+1];\n        else right[i] = a[i];\n    }\n    \n    for(let i=1 ; i&#x3C;len-1 ; i++){\n        if(left[i-1] &#x3C; a[i] &#x26;&#x26; a[i] > right[i+1]) continue;\n        answer++;\n    }\n    answer+=2;\n    return answer;\n}\n</code></pre>","frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 풍선터트리기","date":"2021년 03월 25일, 16:00"}}},"pageContext":{"slug":"/13/post127/","previous":{"fields":{"slug":"/13/post126/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 스타수열","path":"/posts/126"}},"next":{"fields":{"slug":"/13/post128/"},"frontmatter":{"title":"[백준] 1916번 최소비용 구하기","path":"/posts/128"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}