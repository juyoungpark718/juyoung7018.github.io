{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/38/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>섬 연결하기</h2>\n<h3>문제설명</h3>\n<p>n개의 섬 사이에 다리를 건설하는 비용(costs)이 주어질 때, 최소의 비용으로 모든 섬이 서로 통행 가능하도록 만들 때 필요한 최소 비용을 return 하도록 solution을 완성하세요.</p>\n<p>다리를 여러 번 건너더라도, 도달할 수만 있으면 통행 가능하다고 봅니다. 예를 들어 A 섬과 B 섬 사이에 다리가 있고, B 섬과 C 섬 사이에 다리가 있으면 A 섬과 C 섬은 서로 통행 가능합니다.</p>\n<p><strong><em>제한사항</em></strong></p>\n<ul>\n<li>섬의 개수 n은 1 이상 100 이하입니다.</li>\n<li>costs의 길이는 ((n-1) * n) / 2이하입니다.</li>\n<li>임의의 i에 대해, costs[i][0] 와 costs[i][1]에는 다리가 연결되는 두 섬의 번호가 들어있고, costs[i][2]에는 이 두 섬을 연결하는 다리를 건설할 때 드는 비용입니다.</li>\n<li>같은 연결은 두 번 주어지지 않습니다. 또한 순서가 바뀌더라도 같은 연결로 봅니다. 즉 0과 1 사이를 연결하는 비용이 주어졌을 때, 1과 0의 비용이 주어지지 않습니다.</li>\n<li>모든 섬 사이의 다리 건설 비용이 주어지지 않습니다. 이 경우, 두 섬 사이의 건설이 불가능한 것으로 봅니다.</li>\n<li>연결할 수 없는 섬은 주어지지 않습니다.</li>\n</ul>\n<p><strong><em>입출력 예</em></strong></p>\n<table>\n<thead>\n<tr>\n<th>n</th>\n<th>costs</th>\n<th>return</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>4</td>\n<td>[[0,1,1],[0,2,2],[1,2,5],[1,3,1],[2,3,8]]</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p><strong><em>입출력 예 설명</em></strong></p>\n<p>costs를 그림으로 표현하면 다음과 같으며, 이때 초록색 경로로 연결하는 것이 가장 적은 비용으로 모두를 통행할 수 있도록 만드는 방법입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1a2ee75391baab00b86bada27e01eb6f/f73a1/islandConnect.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 91.19999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACzElEQVQ4y32UuW/UUBDGH0gBxCUKxFHQIEQBJTUtBQWiokKi4B9AggqQQDQUFFBQEA5xJRDCpSAKoiDOCEWACKugJQdHYNdZL3s4jte79saeH1o/e48EMdKT3rNnvvdm5vtGgRAKHSbSWI2PEp8lPkcnQlkQADGGoJLNmCWc+yI8ybQCO4E0cBBflHXhxCfhyHthrCxNUNXYvMgJy3oEdQXUVTj2URLMyGquh1f1m8CzPuwcENQlUN2wrk8Yn9XOqhG174WgLsP2x8LSW8LKXvjm+NTFpkaVafMHmcIvXKqATd/P+ch//T1h832JQE9/bgPc/1IDbnssLLklrOqFybkKc0GOgm9iBX8oB3nyfg6fHENmEGXS1SOsuaMBL35tAsIbE1b06h8Nx+OfFnaplX7DysUih155qBugrsGeIaEyr/+pMC7y+CycT1cZNMKOboqEHchZw6BcKkSnt/k6zwyPIGz5Ry+cD3XQPFnAX0QVy7LwPI9MJoNt223wFlCK9kHsq5KgvFlgvJCmThCnJ4TxRSMjI6RSKer1ekyPMPJxxOHbn6kmAxpYKgmamvxOKjtKgHZOLnIch5mZmSZ49PLIASpSIZ1N4zrVFuC/Uk64XCqVMAyjA0y/MOnQP1JOmpJz4fYPh49FHWyaZrQ6JZnITgcPzvg8+lWlFixoymgJNvVrLqqbcGpkjrpjNYFc123WL7GDbyWiWENdu58JdiykiNgHXmsObnkgqBvC2rswbXlUHRvP9xkeHmZiYgK35oNfYdDQMl19R9jQryV4Id2mlL3PtcOOAaGrB5b3CKOGjWMVKZbKUS2LxSL5Qgmqszyc1tlsuCdsfaT1fCbVppSB34K6HqfcDYffLR5P7ebUYdfTWFndsLFf+D7XbIou6GtTOPpBuDrZKnworRGWrGR8FWrC2THh5KgwZXeMr8UDtp0i7bM02f9vwP4FS2wmpb5IypsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"islandConnect\"\n        title=\"islandConnect\"\n        src=\"/static/1a2ee75391baab00b86bada27e01eb6f/0b533/islandConnect.png\"\n        srcset=\"/static/1a2ee75391baab00b86bada27e01eb6f/fac75/islandConnect.png 125w,\n/static/1a2ee75391baab00b86bada27e01eb6f/63868/islandConnect.png 250w,\n/static/1a2ee75391baab00b86bada27e01eb6f/0b533/islandConnect.png 500w,\n/static/1a2ee75391baab00b86bada27e01eb6f/1d69c/islandConnect.png 750w,\n/static/1a2ee75391baab00b86bada27e01eb6f/f73a1/islandConnect.png 822w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n</blockquote>\n<h3>문제설명</h3>\n<ol>\n<li>costs배열을 비용으로 정렬.</li>\n<li>group을 두고 초기화를 시켜준다. 모든 섬이 연결되어있는지 확인하기 위해 필수.</li>\n<li>모든 섬이 연결될 때까지 while문을 돌려준다.(Set을 이용해 group의 원소 같은 숫자인지 확인)</li>\n<li>costs배열에서 way를 뽑는다.</li>\n<li>서로 같은 그룹에 있는지 확인 같지 않으면,\n<ol>\n<li>각 그룹을 구하고, 한쪽 그룹으로 합쳐준다.</li>\n<li>answer에 비용을 더함.</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"language-js\">function solution(n, costs) {\n  let answer = 0;\n  costs.sort((a, b) => b[2] - a[2]);\n  let visited = Array.from(Array(n), (_, index) => index);\n  while (new Set([...visited]).size !== 1) {\n    const [landA, landB, cost] = costs.pop();\n    const groupA = findGroup(visited, landA);\n    const groupB = findGroup(visited, landB);\n    if (groupA === groupB) continue;\n    visited = visited.map((visit, index) => {\n      return visit === groupB ? groupA : visit;\n    });\n    answer += cost;\n  }\n  return answer;\n}\n\nfunction findGroup(arr, land) {\n  while (arr[land] !== land) {\n    land = arr[land];\n  }\n  return land;\n}\n\n// function check(arr){\n//     for(let i=0 ; i&#x3C;arr.length-1 ; i++){\n//         if(arr[i] === arr[i+1]) continue;\n//         return true;\n//     }\n//     return false;\n// }\n</code></pre>\n<h4>아쉬운 점 || 느낀 점</h4>\n<p>처음에는 아 costs를 정렬하고, visited 배열을 만들어서 방문했는지 아닌지 확인하면 되겠구나!라고,<br>\n진짜 1차원적으로 생각해서 풀었는데, 당근 테스트케이스가 무더기로 틀렸다.<br>\n그래서 질문하기 탭에서 힌트를 받았는데, 그룹에 대한 내용을 봐서 풀었다.(<del>사실 다른 사람 코드 살짝 구경함.</del>)<br>\n자료구조, 알고리즘 시간에 크루스칼, 프림, 탐욕법을 하면서 그룹화해서 푸는 코드도 짜봤던 것 같은데,<br>\n까먹어서 못풀다니 너무 안타까웠다. 그래도 힌트를 보고 푼 것은 다행이다.</p>","frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 섬연결하기","date":"2020년 06월 09일, 10:15"}}},"pageContext":{"slug":"/4/post38/","previous":{"fields":{"slug":"/4/post36/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 네트워크","path":"/posts/36"}},"next":{"fields":{"slug":"/4/post39/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 가장 먼 노드","path":"/posts/39"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}