{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/83/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>토마토</h2>\n<h3>문제 설명</h3>\n<p>철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 265px; max-width: 392.7710843373494; height: 400px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c204a66d002fb5b28a2bfa07061cb501/78e79/7569-tomato1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 101.840490797546%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAABYlAAAWJQFJUiTwAAACqUlEQVQ4y23U3U6rTBQGYO//QjzQGGNi1C1iG0phGAYsEoRSsAwgPwMS/lq/gi1fUrZou30PJiHMk7VWmOGk+8put+u6rqqqNE2jKErTNAzDJEn6NY5jQkhZlsPOrutOjrAsy6ZpMgyDMZ5Op57nAQCWyyVCaD6fsyyb5/mw+eSnrOsaQqgoymwfTdMQQoZhAABs25ZleblchmG4Xq97coDn87mmaYqiYIwBAK7rMgzj+/54PK6q6urqCiHUtm2apge4j7QPQkjXdVmWdV0fWtB1/fz83LKspmmSJPnGfdkoiiRJghCapgkhXCwWT09Pi8UCIeQ4zmw2u7y8FEWxaRpCyDGGEL6+vnIc53kewzCO47Asq+s6z/Ou61IUdXZ2ZllWXdffuJfr9RoAoCiKIAgIIU3TOI4zDINlWdu2JUm6v7+/u7uDEPq+v9ls/n6qHruuCyHUNO3l5UWWZdu2RVG0bVsQBIzxZDL5sw9FUUPZbxyGYVEUXde1bfv5+dm27Xa7bZqm67ogCE5PT2mafnx8RAhVVXWMPc+jKIrn+el0yjCMIAjj8VgUxdFoxHHcw8PDzc0Nz/NBEERRdIwJIY7jrFarPM+LohjWqqre3t4uLi5o+lFV1aZpenwwMyFkMpnIsixJkiiKiqIAAFRVFUWR5/nb21uapuOYrFar4YQcYIxxXdf5PkPxsizjOKZpGgCw3W4Jicvyn5nLsgQAzL6iKIqqqrPZ7Pn5GQBwfX3tOM5ms3Ec5+eJ/IuzLDMMw9/H87y3ffpHjDFCqG/t4+PjF5znuWVZeZ4nSUIIib/y/v4eBMFoNPI8r5fDZT64z7Ztm6ZZFMV/P1LXtWEYWZb17Kc8wP3knuf5vp+mSZZlcRxjjI/+Hr/j/vVut2vbtqqqvoVfzYD/B94YPTnTOHEDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tomato1\"\n        title=\"tomato1\"\n        src=\"/static/c204a66d002fb5b28a2bfa07061cb501/78e79/7569-tomato1.png\"\n        srcset=\"/static/c204a66d002fb5b28a2bfa07061cb501/222b7/7569-tomato1.png 163w,\n/static/c204a66d002fb5b28a2bfa07061cb501/78e79/7569-tomato1.png 265w\"\n        sizes=\"(max-width: 265px) 100vw, 265px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.</p>\n<p>토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.</p>\n<p><strong>입력</strong></p>\n<p>첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.</p>\n<p><strong>출력</strong></p>\n<p>여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.</p>\n</blockquote>\n<h3>문제 풀이</h3>\n<ol>\n<li>주어진 input[0]에서 각각 row,column,height를 변수로 가져옴.</li>\n<li>그리고 나머지 input[1]~length까지를 이용해서 3차원 배열을 만들어줌.\n<ol>\n<li>익히지 않은 토마토, totalTomato의 수를 세준다(0인 경우)</li>\n<li>그리고 익은 토마토를 queue로 만들어준다.</li>\n</ol>\n</li>\n<li>totalTomato와 비교할 tempTomato와 모든 토마토가 익히는데 걸린 시간 maxDay를 선언해준다.</li>\n<li>excuteBFS\n<ol>\n<li>익은 토마토 queue가 0이 될 때까지 for문을 돌려준다.\n<ol>\n<li>현재 타겟 토마토의 day와 maxDay를 비교해서 큰 값을 maxDay.</li>\n<li>for문은 상하좌우, 높이까지 해서 돌려준다.\n<ol>\n<li>비정상적인 값은 continue해준다.</li>\n<li>queue에는 index 3번째 즉 day값을 +1해서 넣어준다.</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>excuteBFS가 끝나고, totalTomato와 tempTomato가 같으면 모든 토마토를 들러서 익힌것이고, 아니면 토마토를 모두 익히지 못한 것이다.</li>\n</ol>\n<pre><code class=\"language-js\">const fs = require(\"fs\");\n// const input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\nconst input = fs.readFileSync(\"./stdin\").toString().trim().split(\"\\n\");\n\nconst dx = [1, -1, 0, 0, 0, 0];\nconst dy = [0, 0, 1, -1, 0, 0];\nconst dz = [0, 0, 0, 0, 1, -1];\n\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass Queue {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  insert(value) {\n    const node = new Node(value);\n    if (this.head === null) {\n      this.head = node;\n      this.tail = this.head;\n    } else {\n      this.tail.next = node;\n      this.tail = node;\n    }\n    this.length++;\n  }\n\n  shift() {\n    const tempNode = this.head;\n    this.head = this.head.next;\n    this.length--;\n    return tempNode;\n  }\n}\n\nconst [columnSize, rowSize, heightSize] = input[0]\n  .trim()\n  .split(\" \")\n  .map(element => Number(element));\nlet totalTomato = 0;\n\nconst getTomatoBoxes = inputs => {\n  const boxes = [];\n  const existTomatoes = new Queue();\n  for (let boxIndex = 0; boxIndex &#x3C; inputs.length / rowSize; boxIndex++) {\n    const box = [];\n    for (let row = boxIndex * rowSize; row &#x3C; (boxIndex + 1) * rowSize; row++) {\n      const tomatoes = inputs[row]\n        .trim()\n        .split(\" \")\n        .map(tomato => Number(tomato));\n      tomatoes.forEach((tomato, column) => {\n        if (tomato === 1)\n          existTomatoes.insert([\n            column,\n            row - rowSize * boxIndex >= 0 ? row - rowSize * boxIndex : row,\n            boxIndex,\n            0,\n          ]);\n        if (tomato === 0) totalTomato++;\n      });\n      box.push(tomatoes);\n    }\n    boxes.push(box);\n  }\n  return [boxes, existTomatoes];\n};\n\nconst [tomatoBoxes, existTomatoes] = getTomatoBoxes(\n  input.slice(1, input.length)\n);\n\nconst visited = Array.from(Array(heightSize), () =>\n  Array.from(Array(rowSize), () => Array(columnSize).fill(false))\n);\n\n// 모든 토마토가 익은 것을 확인하기위한 변수\nlet tempTomato = 0;\nlet maxDay = 0;\n\nconst excuteBFS = () => {\n  const queue = existTomatoes;\n  while (queue.length !== 0) {\n    const [x, y, z, day] = queue.shift().value;\n    if (visited[z][y][x]) continue;\n    maxDay = Math.max(maxDay, day);\n    if (tomatoBoxes[z][y][x] === 0) tempTomato++;\n    tomatoBoxes[z][y][x] = 1;\n    visited[z][y][x] = true;\n    //상하좌우 + z값\n    for (let i = 0; i &#x3C; 6; i++) {\n      const nx = x + dx[i];\n      const ny = y + dy[i];\n      const nz = z + dz[i];\n      if (\n        nx &#x3C; 0 ||\n        ny &#x3C; 0 ||\n        nz &#x3C; 0 ||\n        nx >= columnSize ||\n        ny >= rowSize ||\n        nz >= heightSize\n      )\n        continue;\n      if (tomatoBoxes[nz][ny][nx] !== 0 || visited[nz][ny][nx]) continue;\n      queue.insert([nx, ny, nz, day + 1]);\n    }\n  }\n};\n\nexcuteBFS();\n\nif (totalTomato === tempTomato) {\n  console.log(maxDay);\n} else {\n  console.log(-1);\n}\n</code></pre>","frontmatter":{"title":"[백준] 7569번 토마토","date":"2020년 07월 22일, 13:30"}}},"pageContext":{"slug":"/9/post83/","previous":{"fields":{"slug":"/9/post82/"},"frontmatter":{"title":"[백준] 2644번 촌수계산","path":"/posts/82"}},"next":{"fields":{"slug":"/9/post84/"},"frontmatter":{"title":"[백준] 1697번 숨바꼭질","path":"/posts/84"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}