{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/135/","result":{"data":{"markdownRemark":{"html":"<h2>파티</h2>\n<ul>\n<li><a href=\"https://www.acmicpc.net/problem/1238\">https://www.acmicpc.net/problem/1238</a></li>\n</ul>\n<h3>문제풀이</h3>\n<p>자바스크립트는 heap으로 구현된 우선순위큐가 없으므로 구현해주면 좋다..</p>\n<p>다익스트라를 이용해서 풀 수 있는 문제이다.\n두 번 다익스트라를 사용해서 최단 거리를 구해야하는데, X에서 각 도시로 가는길과, X에서 역방향으로 도시로 가는 길 이 두 가지를 구해야한다.</p>\n<ol>\n<li>주어진 도로에 대해서 단방향으로 진행할 수 있는 인접리스트를 만들고, 역방향으로 진행할 수 있는 인접리스트를 만든다.</li>\n<li>각 인접리스트로 다익스트라를 돌리고, distance 배열에서 최댓값을 뽑아주면 된다.</li>\n</ol>\n<h3>소스코드</h3>\n<pre><code class=\"language-js\">const log = console.log;\nconst fs = require(\"fs\");\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n// const input = fs.readFileSync(\"./stdin\").toString().trim().split(\"\\n\");\n\nclass Heap { /* 구현 내용은 생략 */ }\n\nconst [N, M, X] = input[0].split(\" \").map(e => +e);\nlet doro = input.slice(1, 1+M).map(e => e.split(\" \").map(el => +el));\nconst doro2 = doro.reduce((arr, val) => {\n  const [start, end , cost] = val;\n  arr[end] ? arr[end].push([start, cost]) : arr[end] = [[start, cost]];\n  return arr;\n}, []);\ndoro = doro.reduce((arr, val) => {\n  const [start, end, cost] = val;\n  arr[start] ? arr[start].push([end, cost]) : arr[start] = [[end, cost]]; \n  return arr;\n}, []);\n\nconst distance = Array(N+1).fill(Infinity);\nconst visited = Array(N+1).fill(false);\nconst queue = new Heap();\n\nqueue.push([X, 0]);\ndistance[X] = 0;\n\nwhile(queue.size()){\n  const [start, cost] = queue.shift();\n  visited[start] = true;\n  for(let i=0 ; i&#x3C;doro[start].length ; i++){\n    const [v, c] = doro[start][i];\n    if(visited[v]) continue;\n    if(distance[v] > cost + c){\n      distance[v]  = cost + c;\n      queue.push([v, cost+c]);\n    }\n  }\n}\n\nconst distance2 = Array(N+1).fill(Infinity);\nconst visited2 = Array(N+1).fill(false);\nconst queue2 = new Heap();\n\nqueue2.push([X, 0]);\n\ndistance2[X] = 0;\n\nwhile(queue2.size()){\n  const [start, cost] = queue2.shift();\n  visited2[start] = true;\n  for(let i=0 ; i&#x3C;doro2[start].length ; i++){\n    const [v, c] = doro2[start][i];\n    if(visited2[v]) continue;\n    if(distance2[v] > cost + c){\n      distance2[v]  = cost + c;\n      queue2.push([v, cost+c]);\n    }\n  }\n}\n\nlet max = 0;\nfor(let i=1 ; i&#x3C;distance.length ; i++){\n  let result = distance[i] + distance2[i];\n  if(max &#x3C; result){\n    max = result;\n  }\n}\n\nlog(max);\n</code></pre>","frontmatter":{"title":"[백준] 1238번 파티","date":"2021년 04월 16일, 11:50"}}},"pageContext":{"slug":"/14/post135/","previous":{"fields":{"slug":"/14/post134/"},"frontmatter":{"title":"[백준] 1167번 트리의 지름","path":"/posts/134"}},"next":{"fields":{"slug":"/14/post136/"},"frontmatter":{"title":"[프로그래머스] 모두 0으로 만들기","path":"/posts/136"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}