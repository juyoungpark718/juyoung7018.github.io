{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/88/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>맥주 마시면서 걸어가기</h2>\n<h3>문제 설명</h3>\n<p>송도에 사는 상근이와 친구들은 송도에서 열리는 펜타포트 락 페스티벌에 가려고 한다. 올해는 맥주를 마시면서 걸어가기로 했다. 출발은 상근이네 집에서 하고, 맥주 한 박스를 들고 출발한다. 맥주 한 박스에는 맥주가 20개 들어있다. 목이 마르면 안되기 때문에 50미터에 한 병씩 마시려고 한다.</p>\n<p>상근이의 집에서 페스티벌이 열리는 곳은 매우 먼 거리이다. 따라서, 맥주를 더 구매해야 할 수도 있다. 미리 인터넷으로 조사를 해보니 다행히도 맥주를 파는 편의점이 있다. 편의점에 들렸을 때, 빈 병은 버리고 새 맥주 병을 살 수 있다. 하지만, 박스에 들어있는 맥주는 20병을 넘을 수 없다.</p>\n<p>편의점, 상근이네 집, 펜타포트 락 페스티벌의 좌표가 주어진다. 상근이와 친구들이 행복하게 페스티벌에 도착할 수 있는지 구하는 프로그램을 작성하시오.</p>\n<p><strong><em>입력</em></strong></p>\n<p>첫째 줄에 테스트 케이스의 개수 t가 주어진다. (t ≤ 50)</p>\n<p>각 테스트 케이스의 첫째 줄에는 맥주를 파는 편의점의 개수 n이 주어진다. (0 ≤ n ≤ 100).</p>\n<p>다음 n+2개 줄에는 상근이네 집, 편의점, 펜타포트 락 페스티벌 좌표가 주어진다. 각 좌표는 두 정수 x와 y로 이루어져 있다. (두 값 모두 미터, -32768 ≤ x, y ≤ 32767)</p>\n<p>송도는 직사각형 모양으로 생긴 도시이다. 두 좌표 사이의 거리는 x 좌표의 차이 + y 좌표의 차이 이다. (맨해튼 거리)</p>\n<p><strong><em>출력</em></strong></p>\n<p>각 테스트 케이스에 대해서 상근이와 친구들이 행복하게 페스티벌에 갈 수 있으면 \"happy\", 중간에 맥주가 바닥나면 \"sad\"를 출력한다.</p>\n</blockquote>\n<h3>문제 풀이(실패)</h3>\n<ol>\n<li>테스트 케이스를 인풋값에서 추출.</li>\n<li>각 테스트 케이스에 대해서 for문.\n<ol>\n<li>convenience에 destination을 넣어줌.</li>\n<li>queue를 만들고 currentLocation을 시작점으로 설정.\n<ol>\n<li>queue가 0이 될떄까지 while.</li>\n<li>destination의 x,y 값이랑 같으면 happy를 출력.</li>\n<li>convenience의 길이가 i랑 같을때까지 while.\n<ol>\n<li>거리를 구해서 거리가 1000보다 작거나 같으면 queue에 push.</li>\n<li>그렇지 않으면 i를 증가시킴.</li>\n</ol>\n</li>\n<li>happy를 출력하지 못하고 queue의 길이가 0이되면, sad를 출력.</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"language-js\">const fs = require(\"fs\");\n// const input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\nconst input = fs.readFileSync(\"./stdin\").toString().trim().split(\"\\n\");\n\nconst testCaseCount = Number(input[0].trim());\n\nconst getTestCases = (inputs, testCaseCount) => {\n  const cases = [];\n  let index = 0;\n  for (let count = 0; count &#x3C; testCaseCount; count++) {\n    const convenienceCount = Number(inputs[index].trim());\n    let tempIndex = index;\n    index += convenienceCount + 2 + 1;\n    const testCase = {\n      currentLocation: null,\n      destination: null,\n      convenience: [],\n    };\n    for (let location = tempIndex + 1; location &#x3C; index; location++) {\n      if (location === tempIndex + 1)\n        testCase.currentLocation = inputs[location]\n          .trim()\n          .split(\" \")\n          .map(element => Number(element));\n      else if (location === index - 1)\n        testCase.destination = inputs[index - 1]\n          .trim()\n          .split(\" \")\n          .map(element => Number(element));\n      else {\n        testCase.convenience.push(\n          inputs[location]\n            .trim()\n            .split(\" \")\n            .map(element => Number(element))\n        );\n      }\n    }\n    cases.push(testCase);\n  }\n  return cases;\n};\n\nconst testCases = getTestCases(input.slice(1, input.length), testCaseCount);\n\nconst executeBFS = () => {\n  testCases.forEach(testCase => {\n    const { currentLocation, destination } = testCase;\n    let convenience = testCase.convenience;\n    const [endX, endY] = destination;\n    convenience.push(destination);\n    const queue = [currentLocation];\n    while (queue.length) {\n      const [startX, startY] = queue.shift();\n      if (endX === startX &#x26;&#x26; endY === startY) {\n        console.log(\"happy\");\n        return;\n      }\n\n      let i = 0;\n      while (i !== convenience.length) {\n        const [nx, ny] = [\n          Math.abs(startX - convenience[i][0]),\n          Math.abs(startY - convenience[i][1]),\n        ];\n        if (nx + ny &#x3C;= 1000) {\n          queue.push([convenience[i][0], convenience[i][1]]);\n          convenience = convenience.filter((_, id) => id !== i);\n          i = 0;\n          break;\n        } else {\n          i++;\n        }\n      }\n    }\n    console.log(\"sad\");\n  });\n};\n\nexecuteBFS();\n</code></pre>\n<h3>틀린 이유 찾는중.</h3>\n<p>7/27\n왜 틀린지 잘 모르겠다. 어딘가 확실하게 틀렸으니 안돌아가는거 같은데,<br>\nbfs나 dfs말고 플로이드 와샬 알고리즘을 적용해서 풀어보는게 좋을 것 같다.</p>\n<p>다음에 도전해봐야겠다.</p>\n<p>8/1\n틀린 부분 못찾겠어가지고 플로이드와샬알고리즘을 이용해서 풀었다. 어려웠다..</p>\n<h3>문제풀이</h3>\n<ol>\n<li>테스트케이스에서 각 정점들 추출.</li>\n<li>정점의 크기만큼 edge를 표현해줄수 있는 2차원 배열 선언.</li>\n<li>정점을 돌면서 연결이 가능하면 1로 표시(가중치는 중요하지 않음.)</li>\n<li>플로이드 와샬 알고리즘을 통해서 집에서 페스티발까지 도달할 수 있으면 infinity값이 아니여야함.</li>\n</ol>\n<pre><code class=\"language-js\">const fs = require(\"fs\");\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n// const input = fs.readFileSync(\"./stdin\").toString().trim().split(\"\\n\");\n\nconst testCaseCount = Number(input[0].trim());\n\nconst transformStrToArr = (str, splitOption = \" \") => {\n  return str\n    .trim()\n    .split(splitOption)\n    .map(element => Number(element));\n};\n\nconst getTestCases = (inputs, testCaseCount) => {\n  const cases = [];\n  let index = 0;\n  for (let count = 0; count &#x3C; testCaseCount; count++) {\n    const convenienceCount = Number(inputs[index].trim());\n    let tempIndex = index;\n    index += convenienceCount + 2 + 1;\n    const testCase = {\n      vertex: [],\n    };\n    for (let location = tempIndex + 1; location &#x3C; index; location++) {\n      testCase.vertex.push([...transformStrToArr(inputs[location])]);\n    }\n    cases.push(testCase);\n  }\n  return cases;\n};\n\nconst testCases = getTestCases(input.slice(1, input.length), testCaseCount);\n\nconst make2Arr = testCase => {\n  const { vertex } = testCase;\n  const n = vertex.length;\n  const connected = Array.from(Array(n), () => Array(n).fill(Infinity));\n  for (let i = 0; i &#x3C; n; i++) {\n    for (let j = 0; j &#x3C; n; j++) {\n      if (i === j) continue;\n      const [x, y] = vertex[i];\n      const [x2, y2] = vertex[j];\n      const distance = Math.abs(x - x2) + Math.abs(y - y2);\n      if (distance &#x3C;= 1000) {\n        connected[i][j] = 1;\n      }\n    }\n  }\n  return connected;\n};\n\ntestCases.forEach(testCase => {\n  const connected = make2Arr(testCase);\n  const n = connected.length;\n  for (let k = 0; k &#x3C; n; k++) {\n    for (let i = 0; i &#x3C; n; i++) {\n      for (let j = 0; j &#x3C; n; j++) {\n        if (connected[i][j] > connected[i][k] + connected[k][j]) {\n          connected[i][j] = connected[i][k] + connected[k][j];\n        }\n      }\n    }\n  }\n  connected[0][n - 1] !== Infinity ? console.log(\"happy\") : console.log(\"sad\");\n});\n</code></pre>","frontmatter":{"title":"[백준] 9205번 맥주마시면서걸어가기(완)","date":"2020년 07월 27일, 23:50"}}},"pageContext":{"slug":"/9/post88/","previous":{"fields":{"slug":"/9/post87/"},"frontmatter":{"title":"[백준] 2573번 빙산","path":"/posts/87"}},"next":{"fields":{"slug":"/9/post89/"},"frontmatter":{"title":"Git과 명령어","path":"/posts/89"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}