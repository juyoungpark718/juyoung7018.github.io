{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/122/","result":{"data":{"markdownRemark":{"html":"<h3>모나드가 중요한 이유?</h3>\n<ul>\n<li>모나드는 사이드 이펙트를 결과 집합과 함께 포함하는 타입</li>\n<li>함수형 프로그래밍에서 사이드 이펙트가 생기는 경우를 방지하기 위해 사용\n<pre>\n  f:FileName→FILE 인 경우 file이 존재하지 않는다면 에러를 발생시킨다.\n\n  Error의 값을 다음 함수로 전달 하는 것은 다음 함수의 인자와 맞지 않기 때문에 순수 함수성이 깨진다고 볼 수 있다.\n  (다음 함수는 file이 올거라고 기대하기 때문)\n\n  하지만, 모나드를 사용하여 f:FileName→Monad[FILE,Error]와 같이 file과 에러를 같이 포함하는 모나드를 만든다면\n  다음 함수는 모나드를 받아 처리하고, 그 함수는 또 모나드를 반환한다면 순수 함수성을 지킬 수 있다.\n</pre>\n</li>\n<li>사이드 이펙트가 생긴다면 순수 함수의 특성이 깨지고, 함수의 합성이 어려워짐</li>\n<li>함수의 값을 모나드로 받고, 실행 결과도 모나드가 된다면 순수 함수가 되고 함수의 합성을 통해 흐름을 만들 수 있음</li>\n</ul>\n<h3>Functor</h3>\n<ul>\n<li>인자를 받아 Functor를 반환</li>\n<li>map 메소드를 가지고 있음.\n<pre><code class=\"language-js\">function Maybe(value) {\n    this.value = value;\n    this.map = function (fn) {\n        return this.isNothing ? this : Maybe.of(fn(this.value));\n    };\n}\n\nMaybe.of = function (value) {\n    return new Maybe(value);\n};\n\nObject.defineProperty(Maybe.prototype, 'isNothing' , {\n    get: function(){\n      return this.value === null || this.value === undefined;\n    }\n});\n</code></pre>\n</li>\n<li>Maybe functor 예제코드\n<pre><code class=\"language-js\">const log = console.log;\nconst curry = (f) => (a, ...bs) => (bs.length ? f(a, ...bs) : (...as) => f(a, ...as));\nconst curryR = (f) => (a, ...bs) => (bs.length ? f(a, ...bs) : (...as) => f(...as, a));\n\nfunction reduce(f, iter, acc) {\n    if (arguments.length === 2) {\n      iter = iter[Symbol.iterator]();\n      acc = iter.next().value;\n    }\n    for (const e of iter) {\n      acc = f(acc, e);\n    }\n    return acc;\n}\n\nconst go = (a, ...fs) => reduce((a, f) => f(a), fs, a);\n\nfunction Maybe(value) {\n    this.value = value;\n    this.map = function (fn) {\n      return this.isNothing ? this : Maybe.of(fn(this.value));\n    };\n}\n\nMaybe.of = function (value) {\n    return new Maybe(value);\n};\n\nObject.defineProperty(Maybe.prototype, 'isNothing' , {\n    get: function(){\n      return this.value === null || this.value === undefined;\n    }\n});\n\nconst map = curry((fn, functor) => functor.map(fn));\n\nconst books = [\n    { id: \"12\", name: \"the lord of the rings\" },\n    { id: \"34\", name: \"harry poter\" },\n];\n\nconst findBookById = curry((id, books) => {\n    log(\"findBookById\");\n    return books.find((book) => book.id === id)\n});\n\nconst get = curry((key, obj) => {\n    log(\"get\");\n    return obj[key];\n});\n\nconst upperCase = (str) => {\n    log(\"upperCase\");\n    return [...str].map(e => e.toUpperCase()).join('')\n};\n\nconst _val = (functor) => functor.value;\n\ngo(\n    books, \n    Maybe.of,\n    map(findBookById(\"12\")),\n    map(get(\"name\")),\n    map(upperCase),\n    log\n);\n\n// 여기서 문제, 값에 예외가 있는 경우?\n// get, upperCase에 모두 다 예외처리를 할 수 없다.\n\nlog(\"------------------------------\");\n\ngo(\n    books,\n    Maybe.of,\n    map(findBookById(\"56\")),\n    map(get(\"name\")),\n    map(upperCase),\n    log\n)\n</code></pre>\n</li>\n</ul>\n<h3>Monad</h3>\n<ul>\n<li>Functor에서 flatMap이 추가\n<pre><code class=\"language-js\">  function Maybe(value) {\n      this.value = value;\n      this.map = function (fn) {\n        return this.isNothing ? this : Maybe.of(fn(this.value));\n      };\n      this.toString = function(){\n        return this.isNothing ? `Nothing` : `Just(${this.value})`;\n      }\n      this.flatMap = function(fn){\n        return this.isNothing ? this : fn(this.value);\n      }\n  }\n\n  Maybe.of = function (value) {\n      return new Maybe(value);\n  };\n\n  Object.defineProperty(Maybe.prototype, 'isNothing' , {\n      get: function(){\n        return this.value === null || this.value === undefined;\n      }\n  });\n</code></pre>\n</li>\n<li>flatMap을 통해 중첩된 Functor를 중첩된 구조를 풀어줌</li>\n<li>Maybe monad 예제코드</li>\n</ul>\n<pre><code class=\"language-js\">  const log = console.log;\n  const curry = (f) => (a, ...bs) => (bs.length ? f(a, ...bs) : (...as) => f(a, ...as));\n  const curryR = (f) => (a, ...bs) => (bs.length ? f(a, ...bs) : (...as) => f(...as, a));\n\n  function reduce(f, iter, acc) {\n      if (arguments.length === 2) {\n        iter = iter[Symbol.iterator]();\n        acc = iter.next().value;\n      }\n      for (const e of iter) {\n        acc = f(acc, e);\n      }\n      return acc;\n  }\n\n  const go = (a, ...fs) => reduce((a, f) => f(a), fs, a);\n\n  const pipe = (...fs) => (a) => reduce((a, f) => f(a), fs, a);\n\n  const sum = pipe((a) => a+1, (a) => a+2);\n\n  const books = [\n      { id: \"12\", name: \"the lord of the rings\", author: \"J.R.R. Tolkien\" },\n      { id: \"34\", name: \"harry poter\", author: \"J.K. Rowling\" },\n  ];\n\n  function Maybe(value) {\n      this.value = value;\n      this.map = function (fn) {\n        return this.isNothing ? this : Maybe.of(fn(this.value));\n      };\n      this.toString = function(){\n        return this.isNothing ? `Nothing` : `Just(${this.value})`;\n      }\n      this.flatMap = function(fn){\n        return this.isNothing ? this : fn(this.value);\n      }\n  }\n\n  Maybe.of = function (value) {\n      return new Maybe(value);\n  };\n\n  Object.defineProperty(Maybe.prototype, 'isNothing' , {\n      get: function(){\n        return this.value === null || this.value === undefined;\n      }\n  });\n\n  const map = curry((fn, functor) => functor.map(fn));\n\n  const flatMap = curry((fn, monad) => monad.flatMap(fn));\n\n  const findBookById = curry((id, books) => {\n      return books.find((book) => book.id === id)\n  });\n\n\n  // f:filename -> Monad[file,Error]\n  const getBookById = curry((id, books) => \n      pipe(\n        findBookById(id),\n        Maybe.of,\n      )(books));\n\n  const validateBookAuthor = (book) => book.author.indexOf('Rowling') > -1 ? Maybe.of(book) : Maybe.of(null);\n\n  const logProp = curry((key, obj) => {\n      log(obj[key])\n      return obj;\n  });\n\n  // 함수가 functor를 인자로 받고 functor를 반환해버리면 functor의 value값이 functor가 된다.\n\n  go(\n      books,\n      getBookById(\"34\"), // -> Maybe\n      map(validateBookAuthor), // -> Maybe(Maybe)\n      map(map(logProp(\"name\"))),\n  )\n\n  // 해결책 functor.value로 풀어주면 된다.\n\n  // go(\n  //   books,\n  //   getBookById(\"34\"),\n  //   map(validateBookAuthor),\n  //   functor => functor.value,\n  //   map(logProp(\"name\"))\n  // )\n\n  // 해결책2 flatMap\n\n  go(\n      books,\n      getBookById(\"34\"), // functor\n      flatMap(validateBookAuthor), // functor\n      flatMap(logProp(\"name\")),\n      log\n  )\n</code></pre>\n<h3>Monad의 종류</h3>\n<ul>\n<li>Optional/Maybe</li>\n<li>Either</li>\n<li>Future</li>\n</ul>\n<h3>참고</h3>\n<ul>\n<li>자바스크립트로 모나드 구현해보기(<a href=\"https://velog.io/@nakta/FP-in-JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EC%A0%91%ED%95%B4%EB%B3%B4%EB%8A%94-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%95%A8%EC%88%98%EC%9E%90Functor\">https://velog.io/@nakta/FP-in-JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EC%A0%91%ED%95%B4%EB%B3%B4%EB%8A%94-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%95%A8%EC%88%98%EC%9E%90Functor</a>)</li>\n<li>모나드에 대해서 이해해보기(<a href=\"https://blog.burt.pe.kr/tags/%EB%AA%A8%EB%82%98%EB%93%9C/\">https://blog.burt.pe.kr/tags/%EB%AA%A8%EB%82%98%EB%93%9C/</a>)</li>\n<li>자바스크립트로 모나드 구현해보기2 - 영문(<a href=\"https://www.toptal.com/javascript/option-maybe-either-future-monads-js\">https://www.toptal.com/javascript/option-maybe-either-future-monads-js</a>)</li>\n<li>모나드에 대해서 이해해보기(<a href=\"https://www.youtube.com/watch?v=jI4aMyqvpfQ\">https://www.youtube.com/watch?v=jI4aMyqvpfQ</a>)</li>\n</ul>","frontmatter":{"title":"[함수형 프로그래밍] - 모나드","date":"2021년 02월 26일, 20:30"}}},"pageContext":{"slug":"/13/post122/","previous":{"fields":{"slug":"/13/post121/"},"frontmatter":{"title":"Reflow, repaint","path":"/posts/121"}},"next":{"fields":{"slug":"/13/post123/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 광고 삽입","path":"/posts/123"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}