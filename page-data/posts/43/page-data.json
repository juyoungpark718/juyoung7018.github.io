{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/43/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>여행경로</h2>\n<h3>문제설명</h3>\n<p>주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 ICN 공항에서 출발합니다.</p>\n<p>항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solution 함수를 작성해주세요.</p>\n<p><strong><em>제한사항</em></strong></p>\n<ul>\n<li>모든 공항은 알파벳 대문자 3글자로 이루어집니다.</li>\n<li>주어진 공항 수는 3개 이상 10,000개 이하입니다.</li>\n<li>tickets의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다.</li>\n<li>주어진 항공권은 모두 사용해야 합니다.</li>\n<li>만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다.</li>\n<li>모든 도시를 방문할 수 없는 경우는 주어지지 않습니다.</li>\n</ul>\n<p><strong><em>입출력 예</em></strong></p>\n<table>\n<thead>\n<tr>\n<th>tickets</th>\n<th>return</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[[ICN, JFK], [HND, IAD], [JFK, HND]]</td>\n<td>[ICN, JFK, HND, IAD]</td>\n</tr>\n<tr>\n<td>[[ICN, SFO], [ICN, ATL], [SFO, ATL], [ATL, ICN], [ATL, SFO]]</td>\n<td>[ICN, ATL, ICN, SFO, ATL, SFO]</td>\n</tr>\n</tbody>\n</table>\n<p><strong><em>입출력 예 설명</em></strong></p>\n<p><strong>예제 #1</strong></p>\n<p>[ICN, JFK, HND, IAD] 순으로 방문할 수 있습니다.</p>\n<p><strong>예제 #2</strong></p>\n<p>[ICN, SFO, ATL, ICN, ATL, SFO] 순으로 방문할 수도 있지만 [ICN, ATL, ICN, SFO, ATL, SFO] 가 알파벳 순으로 앞섭니다.</p>\n</blockquote>\n<h3>문제풀이</h3>\n<p>가장 중요한 포인트는 2가지이다.</p>\n<ol>\n<li>\n<p>티켓은 중복이 가능한 것.(ex. [ICN, SFO], [ICN, SFO])</p>\n</li>\n<li>\n<p>경로가 2가지 이상인 경우 알파벳 순.\n티켓 중복을 생각 못해서 진짜 계속 틀렸다.</p>\n</li>\n<li>\n<p>tickets을 알파벳 순으로 정렬(알파벳이 앞선 경로를 선택하기 위해.)</p>\n</li>\n<li>\n<p>tickets에 index를 붙여줌.(중복된 티켓을 구별.)</p>\n</li>\n<li>\n<p>dfs를 시작.</p>\n<ol>\n<li>start에서 고를 수 있는 티켓을 뽑음.(can)</li>\n<li>tickets의 길이와 can의 길이가 모두 0이라면,\n<ol>\n<li>모든 지점을 방문.</li>\n<li>tickets의 길이가 0이 아닌데, can의 길이가 0이라면 모든 지점을 방문 X.</li>\n<li>can에서 자기 자신을 제외한 모든 경로를 다시 또 dfs를 돌림.</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>dfs가 끝난 뒤, answer에는 여러 가지의 경로가 담겨져 있지만, 알파벳 순으로 정렬한 뒤에 dfs를 했으므로 알파벳순으로 정렬되어 있음.</p>\n</li>\n<li>\n<p>answer는 results의 첫 번째 원소이고, 뽑은 첫 번째 원소에 ICN을 뽑은 배열의 앞에 추가해주고 그것을 리턴.</p>\n</li>\n</ol>\n<pre><code class=\"language-js\">function solution(tickets) {\n  var answer = [];\n  tickets.sort();\n  tickets = tickets.map((e, id) => {\n    return [id, e[0], e[1]];\n  });\n  dfs(\"ICN\", tickets, [], answer);\n  answer = answer.shift();\n  answer.unshift(\"ICN\");\n  return answer;\n}\n\nfunction dfs(start, tickets, result, answer) {\n  let can = [];\n  tickets.forEach(e => {\n    if (e[1] === start) {\n      can.push(e);\n    }\n  });\n  // console.log(can);\n  if (can.length === 0 &#x26;&#x26; tickets.length === 0) answer.push(result);\n  if (can.length === 0 &#x26;&#x26; tickets.length !== 0) return;\n  can.forEach((e, id) => {\n    let others = tickets.filter(el => {\n      if (el[1] === e[1] &#x26;&#x26; el[2] === e[2] &#x26;&#x26; el[0] === e[0]) return false;\n      else return true;\n    });\n    result.push(e[2]);\n    let newResult = [...result];\n    result.pop();\n    dfs(e[2], others, newResult, answer);\n  });\n}\n</code></pre>\n<h4>아쉬운 점 || 느낀 점</h4>\n<p>처음에는 큐를 이용해서 풀려고 했지만, 안풀려 재귀를 이용해서 풀었다.<br>\n하지만, 알파벳 순서는 잘 적용했지만, 중복 티켓에 대한 내용은 문제에 없어 생각을 못했음.<br>\n1번 테스트 케이스의 경우가 중복티켓을 포함하는 경우였는데, 계속 틀렸음.</p>","frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 여행경로","date":"2020년 06월 14일, 15:19"}}},"pageContext":{"slug":"/5/post43/","previous":{"fields":{"slug":"/5/post42/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 단속카메라","path":"/posts/42"}},"next":{"fields":{"slug":"/5/post44/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 이중우선순위큐","path":"/posts/44"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}