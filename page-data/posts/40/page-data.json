{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/40/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>단어 변환</h2>\n<h3>문제 설명</h3>\n<p>두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.</p>\n<pre><code>1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.\n2. words에 있는 단어로만 변환할 수 있습니다.\n</code></pre>\n<p>예를 들어 begin이 hit, target가 cog, words가 [hot,dot,dog,lot,log,cog]라면 hit -> hot -> dot -> dog -> cog와 같이 4단계를 거쳐 변환할 수 있습니다.</p>\n<p>두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.</p>\n<p><strong><em>제한사항</em></strong></p>\n<ul>\n<li>각 단어는 알파벳 소문자로만 이루어져 있습니다.</li>\n<li>각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다.</li>\n<li>words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다.</li>\n<li>begin과 target은 같지 않습니다.</li>\n<li>변환할 수 없는 경우에는 0를 return 합니다.</li>\n</ul>\n<p><strong><em>입출력 예</em></strong></p>\n<table>\n<thead>\n<tr>\n<th>begin</th>\n<th>target</th>\n<th>words</th>\n<th>return</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hit</td>\n<td>cog</td>\n<td>[hot, dot, dog, lot, log, cog]</td>\n<td>4</td>\n</tr>\n<tr>\n<td>hit</td>\n<td>cog</td>\n<td>[hot, dot, dog, lot, log]</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p><strong><em>입출력 예 설명</em></strong></p>\n<p><strong>예제 #1</strong>\n문제에 나온 예와 같습니다.</p>\n<p><strong>예제 #2</strong>\ntarget인 cog는 words 안에 없기 때문에 변환할 수 없습니다.</p>\n</blockquote>\n<h3>문제풀이</h3>\n<ol>\n<li>처음 시작 단어를 포함한 배열 begins를 만들어서, 처음 시작 단어에서 바꿀 수 있는 단어들로 갱신을 반복.</li>\n<li>words는 선택된 단어들은 줄여줌.\n<ol>\n<li>선택되는 단어의 기준은 begins 배열의 원소와 같은 문자가 word.length(begins 배열의 원소의 길이) - 1이랑 같은 원소.</li>\n<li>선택된 단어는 newBegins에 넣어주고, words에서는 삭제.</li>\n</ol>\n</li>\n<li>한번의 과정이 끝나면 cost를 증가시켜주고 다시 함수 호출.</li>\n<li>끝나는 조건은,\n<ol>\n<li>begins배열에 있는 원소들 중 target이랑 일치하는 값이 있는 경우.</li>\n<li>begins의 배열의 길이가 0인 경우(target을 만들 수 없는 경우).</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"language-js\">function solution(begin, target, words) {\n  var answer = 0;\n  answer = abc([begin], target, words, 0);\n  return answer;\n}\n\nfunction abc(begins, target, words, cost) {\n  if (begins.includes(target)) return cost;\n  if (begins.length === 0) return 0;\n  let newBegins = [];\n  begins.forEach(e => {\n    words = words.filter(word => {\n      let count = 0;\n      [...e].forEach((el, idx) => {\n        if (word[idx] === el) count++;\n      });\n      if (count === word.lenght - 1) {\n        newBegins.push(word);\n        count = 0;\n        return false;\n      } else {\n        count = 0;\n        return true;\n      }\n    });\n  });\n  return abc(newBegins, target, words, ++cost);\n}\n</code></pre>\n<h4>아쉬운 점 || 느낀 점</h4>\n<p>레벨2에서 재귀함수를 너무 많이 사용하다보니,<br>\nlevel3에서도 재귀함수를 너무 이용하는 듯한 느낌이 든다.<br>\n다른 사람 풀이를 보니 while문을 돌려서 풀 수 있는 방법이 있는데도,<br>\n생각이 계속 재귀에 머무른다.<br>\n재귀 함수는 어느정도 짜는거 같으니 다른 방법으로 푸는 것을 연습해야겠다.(<del>맨날 말만함..</del>)</p>","frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 단어 변환","date":"2020년 06월 11일, 18:35"}}},"pageContext":{"slug":"/4/post40/","previous":{"fields":{"slug":"/4/post39/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 가장 먼 노드","path":"/posts/39"}},"next":{"fields":{"slug":"/5/post41/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 예산","path":"/posts/41"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}