{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/134/","result":{"data":{"markdownRemark":{"html":"<h2>트리의 지름</h2>\n<h3>문제풀이</h3>\n<p>dfs, bfs로 풀면 되는 문제다.\n<del>문제를 잘 읽자..</del></p>\n<h3 style=\"color:#DF4930;\">주의할 점! 주어지는 간선들의 정보가 주어진 정점의 순서대로가 아니다!</h2>\n  <pre>\n    ex)\n    5\n    1 3 2 -1\n    2 4 4 -1\n    3 1 2 4 3 -1\n    4 2 4 3 3 5 6 -1\n    5 4 6 -1\n    위와 같이 주어질 수 있지만,\n    5\n    5 4 6 -1\n    3 1 2 4 3 -1\n    4 2 4 3 3 5 6 -1\n    2 4 4 -1\n    1 3 2 -1\n    이렇게 주어질 수도 있다.\n\n    4%까지가서 틀린다면, 이 경우를 확인해봐야한다.\n  </pre>\n<h3>소스코드</h3>\n<h3>DFS</h3>\n<pre><code class=\"language-js\">const log = console.log;\nconst fs = require(\"fs\");\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n// const input = fs.readFileSync(\"./stdin\").toString().trim().split(\"\\n\");\n\nconst vertex = +input[0];\nlet edge = input.slice(1, vertex+1).map(e => e.split(\" \").map(el => +el));\nedge = edge.reduce((acc, val) => {\n  const [index, ...rest] = val;\n  acc[index-1] = val;\n  return acc;\n},[]);\nconst visited = Array(vertex).fill(false);\nlet d = 0;\nlet node = 1;\n\nconst dfs = (start, acc, visited) => {\n  visited[start-1] = true;\n  if(d &#x3C; acc){\n    d = acc;\n    node = start;\n  }\n  for(let i=1 ; i&#x3C;edge[start-1].length ; i += 2){\n    if(edge[start-1][i] === -1) break;\n    if(visited[edge[start-1][i]-1]) continue;\n    dfs(edge[start-1][i], acc+edge[start-1][i+1], visited);\n  }\n}\n\ndfs(1, 0, [...visited]);\ndfs(node, 0, [...visited]);\nlog(d);\n</code></pre>\n<h3>BFS</h3>\n<pre><code class=\"language-js\">const log = console.log;\nconst fs = require(\"fs\");\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n// const input = fs.readFileSync(\"./stdin\").toString().trim().split(\"\\n\");\n\nconst vertex = +input[0];\nlet edge = input.slice(1, vertex+1).map(e => e.split(\" \").map(el => +el));\nedge = edge.reduce((acc, val) => {\n  const [index, ...rest] = val;\n  acc[index-1] = val;\n  return acc;\n},[]);\nconst visited = Array(vertex).fill(false);\nlet d = 0;\nlet node = 1;\n\nclass Queue{\n  arr = [];\n  head = 0;\n  tail = 0;\n\n  push(value){    \n    if(value instanceof Array){\n      this.arr.push(...value);\n      this.tail += value.length;\n    }else{\n      this.arr.push(value);\n      this.tail++;\n    }\n  }\n\n  shift(){\n    if(this.size() === 0) return undefined;\n    return this.arr[this.head++];\n  }\n\n  size(){\n    return this.tail - this.head;\n  }\n}\n\nconst bfs = (start, visited) => {\n  const queue = new Queue();\n  queue.push({ s:start, c:0 });\n  while(queue.size()){\n    const { s, c } = queue.shift();\n    for(let i=1 ; i&#x3C;edge[s-1].length ; i +=2 ){\n      if(edge[s-1][i] === -1) break;\n      if(visited[edge[s-1][i]-1]) continue;\n      queue.push({ s: edge[s-1][i], c: edge[s-1][i+1] + c });\n      if(d &#x3C; edge[s-1][i+1] + c){\n        d = edge[s-1][i+1] + c;\n        node = edge[s-1][i];\n      }\n    }\n    visited[s-1] = true;\n  }\n}\nbfs(1, [...visited]);\nbfs(node, [...visited]);\nlog(d);\n</code></pre>","frontmatter":{"title":"[백준] 1167번 트리의 지름","date":"2021년 04월 14일, 20:40"}}},"pageContext":{"slug":"/14/post134/","previous":{"fields":{"slug":"/14/post133/"},"frontmatter":{"title":"[백준] 15686번 치킨배달","path":"/posts/133"}},"next":{"fields":{"slug":"/14/post135/"},"frontmatter":{"title":"[백준] 1238번 파티","path":"/posts/135"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}