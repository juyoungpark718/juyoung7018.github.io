{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/78/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>유기농 배추</h2>\n<h3>문제 설명</h3>\n<p>차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 > 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.</p>\n<p>(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)</p>\n<p>한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다.</p>\n<p>예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다.</p>\n<p>(0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.)</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td><strong>1</strong></td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td><strong>1</strong></td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td><strong>1</strong></td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td><strong>1</strong></td>\n<td>0</td>\n<td>0</td>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n<td><strong>1</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong><em>입력</em></strong></p>\n<p>입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다.</p>\n<p><strong>출력</strong></p>\n<p>각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.</p>\n</blockquote>\n<h3>문제 풀이</h3>\n<ol>\n<li>테스트케이스가 여러 개 주어지기 때문에, 테스트케이스를 나누는 함수 구현.</li>\n<li>searchGroup\n<ol>\n<li>테스트케이스에 따른 지렁이를 저장.(earthWorm).</li>\n<li>testCases를 for문.\n<ol>\n<li>group, groupId를 선언.</li>\n<li>stack를 선언.</li>\n<li>vertexs 배열의 길이가 0이 될 때까지 while.\n<ol>\n<li>vertex의 x,y좌표를 선언하는데,\n<ol>\n<li>stack의 길이가 0이면서, 방문하지 않은 좌표라면 새로운 group로 판단, vertexs 배열에서 원소를 뽑는다.</li>\n<li>stack의 길이가 0이 아니라면 같은 그룹, stack에서 원소를 뽑는다.</li>\n</ol>\n</li>\n<li>뽑은 점이 방문한 점이라면 continue.</li>\n<li>방문한 점이 아니라면,\n<ol>\n<li>visitedLand를 true 바꿔줌.(점을 방문.)</li>\n<li>상하좌우의 연결되어 있는 점을 찾기 위해 for문.</li>\n<li>비정상적인 x,y좌표(마이너스 값 또는 크기를 넘어가는 값),land가 0인 값은 continue.</li>\n<li>정상적인 좌표라면 stack에 push.</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>while문이 끝난 후 group의 길이를 earthWorm에 push.</li>\n</ol>\n</li>\n<li>earthWorm을 리턴.</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"language-js\">const fs = require(\"fs\");\nconst input = fs.readFileSync(\"/dev/stdin\").toString().trim().split(\"\\n\");\n// const input = fs.readFileSync(\"./stdin\").toString().trim().split(\"\\n\");\n\nconst dx = [1, 0, -1, 0];\nconst dy = [0, 1, 0, -1];\n\n// testCase = {row,column,vertexs,land}\nconst getTestCases = (input, count) => {\n  let nextTestCaseIndex = 0;\n  const testCases = [];\n  for (let i = 0; i &#x3C; count; i++) {\n    const [row, column, vertexsLength] = input[nextTestCaseIndex]\n      .split(\" \")\n      .map(element => Number(element));\n    const vertexsInput = input.slice(\n      nextTestCaseIndex + 1,\n      nextTestCaseIndex + vertexsLength + 1\n    );\n    const vertexs = [];\n    vertexsInput.forEach(input => {\n      const [x, y] = input.split(\" \").map(element => Number(element));\n      vertexs.push([x, y]);\n    });\n\n    const land = Array.from(Array(row), () => Array(column).fill(0));\n    const visitedLand = Array.from(Array(row), () => Array(column).fill(false));\n    vertexs.forEach(edge => (land[edge[0]][edge[1]] = 1));\n\n    const testCase = {\n      row,\n      column,\n      vertexs,\n      land,\n      visitedLand,\n    };\n    testCases.push(testCase);\n    nextTestCaseIndex += vertexsLength + 1;\n  }\n  return testCases;\n};\n\nconst searchGroup = testCases => {\n  const earthWorm = [];\n  testCases.forEach(testCase => {\n    const { row, column, vertexs, land, visitedLand } = testCase;\n    const group = [];\n    let groupId = 1;\n    let stack = [];\n    while (vertexs.length !== 0) {\n      let [vertexX, vertexY] = [null, null];\n      if (stack.length === 0) {\n        [vertexX, vertexY] = vertexs.pop();\n        if (!visitedLand[vertexX][vertexY]) {\n          group.push(groupId);\n          groupId++;\n        }\n      } else {\n        [vertexX, vertexY] = stack.pop();\n      }\n\n      if (visitedLand[vertexX][vertexY]) continue;\n      visitedLand[vertexX][vertexY] = true;\n      //상하좌우\n      for (let i = 0; i &#x3C; 4; i++) {\n        let nx = vertexX + dx[i];\n        let ny = vertexY + dy[i];\n        if (nx &#x3C; 0 || ny &#x3C; 0 || nx >= row || ny >= column || land[nx][ny] === 0)\n          continue;\n        stack.push([nx, ny]);\n      }\n    }\n    earthWorm.push(group.length);\n  });\n  return earthWorm;\n};\n\nconst testCaseCount = Number(input[0]);\nconst testCases = getTestCases(input.slice(1, input.length), testCaseCount);\nconst answer = searchGroup(testCases);\nanswer.forEach(element => console.log(element));\n</code></pre>","frontmatter":{"title":"[백준] 1012번 유기농 배추","date":"2020년 07월 17일, 14:00"}}},"pageContext":{"slug":"/8/post78/","previous":{"fields":{"slug":"/8/post77/"},"frontmatter":{"title":"[백준] 1260번 DFS와BFS","path":"/posts/77"}},"next":{"fields":{"slug":"/8/post79/"},"frontmatter":{"title":"[백준] 2178번 미로 탐색","path":"/posts/79"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}