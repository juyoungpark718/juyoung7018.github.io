{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/31/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<h2>추석트래픽</h2>\n<h3>문제설명</h3>\n<p>이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.</p>\n<p><strong><em>입력 형식</em></strong></p>\n<ul>\n<li>solution 함수에 전달되는 lines 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다.</li>\n<li>응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 2016-09-15 hh:mm:ss.sss 형식으로 되어 있다.</li>\n<li>처리시간 T는 0.1s, 0.312s, 2s 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 s로 끝난다.</li>\n<li>예를 들어, 로그 문자열 2016-09-15 03:10:33.020 0.011s은 2016년 9월 15일 오전 3시 10분 <strong>33.010초</strong>부터 2016년 9월 15일 오전 3시 10분 <strong>33.020초</strong>까지 <strong>0.011초</strong> 동안 처리된 요청을 의미한다. (처리시간은 시작시간과 끝시간을 포함)</li>\n<li>서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다.</li>\n<li>lines 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다.</li>\n</ul>\n<p><strong><em>출력 형식</em></strong></p>\n<p>solution 함수에서는 로그 데이터 lines 배열에 대해 초당 최대 처리량을 리턴한다.</p>\n<p><strong><em>입출력 예제</em></strong></p>\n<p><strong>예제1</strong></p>\n<ul>\n<li>\n<p>입력: [</p>\n<blockquote>\n<p>2016-09-15 01:00:04.001 2.0s,\n2016-09-15 01:00:07.000 2s\n]</p>\n</blockquote>\n</li>\n<li>\n<p>출력: 1</p>\n</li>\n</ul>\n<p><strong>예제2</strong></p>\n<ul>\n<li>\n<p>입력: [</p>\n<blockquote>\n<p>2016-09-15 01:00:04.002 2.0s,\n2016-09-15 01:00:07.000 2s\n]</p>\n</blockquote>\n</li>\n<li>\n<p>출력: 2</p>\n</li>\n</ul>\n<p>설명: 처리시간은 시작시간과 끝시간을 포함하므로\n첫 번째 로그는 01:00:02.003 ~ 01:00:04.002에서 2초 동안 처리되었으며,\n두 번째 로그는 01:00:05.001 ~ 01:00:07.000에서 2초 동안 처리된다.\n따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 01:00:04.002 ~ 01:00:05.001 1초 동안 최대 2개가 된다.</p>\n<p><strong>예제3</strong></p>\n<ul>\n<li>\n<p>입력: [</p>\n<blockquote>\n<p>2016-09-15 20:59:57.421 0.351s,\n2016-09-15 20:59:58.233 1.181s,\n2016-09-15 20:59:58.299 0.8s,\n2016-09-15 20:59:58.688 1.041s,\n2016-09-15 20:59:59.591 1.412s,\n2016-09-15 21:00:00.464 1.466s,\n2016-09-15 21:00:00.741 1.581s,\n2016-09-15 21:00:00.748 2.31s,\n2016-09-15 21:00:00.966 0.381s,\n2016-09-15 21:00:02.066 2.62s\n]</p>\n</blockquote>\n</li>\n<li>\n<p>출력: 7</p>\n</li>\n<li>\n<p>설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 (1)은 4개, (2)는 7개, (3)는 2개임을 알 수 있다. 따라서 초당 최대 처리량은 7이 되며, 동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다.</p>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 393px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/108c73ed5b3d49fc07126aefd6dfb5a7/d72ec/chusok-traffic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACIElEQVQ4y5WU63LaMBCFef8nyyQ/0iaBQgDjS5Av+CbbWLax/HUkCLl22mpGM7tr7dE5uyvPtNboaWK67LPN1b/GtWbiLc6H8+bLec0W8zm/FivyLGO1XPLz/h6xF6yWa+YPjwghcByHp8c5QoQ46zWLxYo4jtmsNzz8+EkUJ3RdxzAMzFRdkwUBrVL0w0AnBL2UqGGgzVK6pkF1HW3b0vU9Kk1pj0c6c7YoaMvS5tV1fQac+h5vPidKElTf0+52TMejpT9VFZxOZ/tVlpRMWp/t45FJKd6v2agUqeexF4Ltbodzc2NvNmuUEvoekz6Oo43pskS/XtI0jG37obazk1IMRWHZGUD37g7hOAymCXUNw2AT9IWVBbyAvwK+V2AZqsPBOqYuydMTu8WCfRwTbjaEvs9pHK8Mp/8BNKFRCFtDk/KyWuFvt+zDkJcgIC+KbyX/EdCI0mHIqaosYB4EuM/PeL6P67q4nkcZBEb/uW7/Anja70k8jzBJrOTE+IeDnbswDDk4zluXTUO67u8MUcoyoK5ppSTNMoo8J4pjlre3hEJQNA2p71Ol6TeAZkyGwXZSJ8n5ZtVZSWbwSymRUlI3DU0UUZUlVXJAJglNnn8G7FCuC3thwfR2Cy8Bk+sxmvgnSaQZRCF4PsTxdbCvgF3bIj3PFlorhY6i62vQWfp1sGWJbhqmcWTKc8bPNTQyx4szXfYX+/0f5rszl7gB/A1eWIcV3VhPPgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"chosuk-traffic\"\n        title=\"chosuk-traffic\"\n        src=\"/static/108c73ed5b3d49fc07126aefd6dfb5a7/d72ec/chusok-traffic.png\"\n        srcset=\"/static/108c73ed5b3d49fc07126aefd6dfb5a7/fac75/chusok-traffic.png 125w,\n/static/108c73ed5b3d49fc07126aefd6dfb5a7/63868/chusok-traffic.png 250w,\n/static/108c73ed5b3d49fc07126aefd6dfb5a7/d72ec/chusok-traffic.png 393w\"\n        sizes=\"(max-width: 393px) 100vw, 393px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n</blockquote>\n<h2>문제 설명</h2>\n<p>레벨3 문제라서 그런지 뭔가 더 어렵게 느껴졌..(<del>그리고 어렵다.</del>)<br>\n문제 이해도 힘든편이였다. 그리고 가장 힘들었던 부분은 처리시간에 시작,끝이 포함되는 것이였다.<br>\n아직도 사실 잘 이해가 가지 않는다.. 진짜 너무 어렵다..</p>\n<ol>\n<li>Date를 통해 getTime()으로 millsecond를 반환하여<br>\nlines를 {start, end}값으로 변환.(어차피 9-15일에 대해서만 계산하니까 값을 줄이기 위해 전역변수 de를 선언해서 빼줌.)<br>\n시작시간,끝시간을 포함하니까 start를 구해주는 과정에서 +1을 해줘야함.</li>\n<li>start, end를 기준점으로 잡아서 포함되는 line들을 체크.\n<ol>\n<li>포함되는 시간은 1초를 더하는 것이지만, 시작시간과 끝시간을 포함하니까 +999.</li>\n<li>포함되는 line들의 수를 count</li>\n<li>start를 기준으로 한 line count의 최댓값 , end를 기준으로 한 line count의 최댓값 중 max값을 answer로 리턴.</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"language-js\">const de = new Date(\"2016-09-14 23:59:57\").getTime();\n\nfunction solution(lines) {\n  var answer = 0;\n  let hashs = makeHashArr(lines);\n  // console.log(hashs)\n  let starts = hashs.map(e => e.start);\n  let ends = hashs.map(e => e.end);\n  let startMax = 0;\n  let endMax = 0;\n  ends.forEach(end => {\n    let count = 0;\n    hashs.forEach(e => {\n      if (checkTime(e, end)) {\n        count++;\n      }\n    });\n    endMax = Math.max(endMax, count);\n  });\n  starts.forEach(start => {\n    let count = 0;\n    hashs.forEach(e => {\n      if (checkTime(e, start)) {\n        count++;\n      }\n    });\n    startMax = Math.max(startMax, count);\n  });\n  // console.log(startMax,endMax);\n  answer = Math.max(startMax, endMax);\n  return answer;\n}\n\nfunction makeHash(line) {\n  const splited = line.split(\" \");\n  const date = new Date(`${splited[0]} ${splited[1]}`).getTime() - de;\n  const execute = parseFloat(splited[2]) * 1000;\n\n  return { start: date + 1 - execute, end: date };\n}\n\nfunction makeHashArr(lines) {\n  return lines.map(e => makeHash(e));\n}\n\nfunction checkTime(hash, time) {\n  if (hash.start &#x3C; time &#x26;&#x26; hash.end &#x3C; time) {\n    return false;\n  } else if (hash.start > time + 999 &#x26;&#x26; hash.end > time + 999) {\n    return false;\n  }\n  return true;\n}\n\n/*\n임의 시간부터 1초\n\n*/\n</code></pre>\n<h4>아쉬운 점 || 느낀 점</h4>\n<p>레벨3부터는 문제 자체도 복잡해지고, 조건들도 더 복잡해지는 것 같다.<br>\n이해하는 과정도 힘들고, 이해를 했다고 생각했는데 여러 조건들을 이해를 못해서 틀리는 것 같다.<br>\n이런 부분을 갈수록 줄여야하는데 쉽지않다.. ㅠㅠ</p>","frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 추석트래픽","date":"2020년 06월 02일, 13:40"}}},"pageContext":{"slug":"/4/post31/","previous":{"fields":{"slug":"/3/post30/"},"frontmatter":{"title":"[프로그래머스] 레벨2 (level2) n진수게임","path":"/posts/30"}},"next":{"fields":{"slug":"/4/post32/"},"frontmatter":{"title":"[프로그래머스] 레벨3 (level3) 종이접기","path":"/posts/32"}}}},"staticQueryHashes":["3649515864"],"slicesMap":{}}